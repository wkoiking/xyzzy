=======================================================================
                UNLHA32.DLL Ver 2.67a  API 説明ファイル
=======================================================================

                                               Ｍｉｃｃｏ (Sep.12,2010)

########################################################################
##########                                                     #########
########## UNLHA32.DLL はスレッド・セーフではありません。(^^;) #########
########## 従って， 複数スレッドからの同時使用は行えませんので #########
########## 注意してください。                                  #########
##########                                                     #########
########## Ver 2.39a からは， UNLHA32.H が ANSI/Unicode 兼用の #########
########## ものへ変更となっています。マクロ UNICODE の定義有無 #########
########## によって，"Unlha" といった従来の API 名については， #########
########## 対象 API が異なってきますので， UNLHA32.H と UNLHA- #########
########## 32.LIB を使用して静的 (暗黙) リンクを行う場合は注意 #########
########## してください。                                      #########
##########                                                     #########
########################################################################

はじめに

　UNLHA32.DLL のドキュメント構成は以下のようになっています。

    API.TXT      : 基幹を成す Unlha() 系及び OpenArchive() 系 API の説明
    NOTE2.TXT    : API.TXT の補足説明
    COMMAND.TXT  : Unlha() に渡すコマンド文字列についての説明
    NOTE.TXT     : COMMAND.TXT の補足説明
    WINMES.TXT   : SetOwnerWindow() 系 API の説明
    ENUMAPI.TXT  : SetEnumMembersProc() 系 API の説明
    STRTABLE.TXT : ストリングテーブルと言語設定用 API についての説明
    HEADER.TXT   : LZH 書庫ヘッダ仕様の説明
    INFCOM.TXT   : Win32SFXM で使用される $ ファイルコマンドの説明
    QandA.TXT    : 過去にあった主な質問集
    HISTORY.TXT  : 修正履歴

　このドキュメントでは基幹を成す LHA.DLL 互換 API と OpenArchive() 系 API，
それと，その他一部の API について説明しています。

　善悪はともかく， Windows での API 呼び出しや DLL の使用に際しては C の知
識が必須となっており，このドキュメントに於いても  C を前提として説明が行わ
れています。 最低でも，ご自分の使用開発ツールと C の違いについて把握した上
で，このドキュメントに目を通すようにしてください。

　ご自分の使用開発ツールでの DLL  の扱い方が分からない場合には，『統合アー
カイバプロジェクト』http://www.csdinc.co.jp/archiver/ から適当にリンクをた
どれば，VB や Delphi 等であれば UNLHA32.DLL の使用法についての情報が得られ
ます。


-----------------------------------------------------------------------
%0. 概要。
%1. 各 API の説明。

        LHA.DLL 互換 API

        %a UnlhaGetVersion                      DLL の版の取得
        %b UnlhaGetRunning                      DLL の実行状況の取得
        %c UnlhaGetBackGroundMode               DLL の動作モードの取得
        %d UnlhaSetBackGroundMode               DLL の動作モードの設定
        %e UnlhaGetCursorMode                   カーソル表示モードの取得
        %f UnlhaSetCursorMode                   カーソル表示モードの設定
        %g UnlhaGetCursorInterval               回転タイミングの取得
        %h UnlhaSetCursorInterval               回転タイミングの設定
        %i Unlha                                書庫操作一般
        %j UnlhaCheckArchive                    書庫のチェック
        %k UnlhaGetFileCount                    格納ファイル数の取得
        %l UnlhaQueryFunctionList               対応 API の問い合わせ
        %m UnlhaConfigDialog                    DLL の設定
        %o UnlhaExtractMem                      メモリーへの展開
        %p UnlhaCompressMem                     メモリーからの格納

        OpenArchive 系 API

        %q UnlhaOpenArchive                     書庫のオープン
        %q UnlhaOpenArchive2                    書庫のオープン
        %r UnlhaCloseArchive                    書庫のクローズ
        %s UnlhaFindFirst                       格納ファイルの検索
        %t UnlhaFindNext                        格納ファイルの検索
        %u UnlhaGetArcFileName                  書庫名の取得
        %v UnlhaGetArcFileSize                  書庫サイズの取得
        %v UnlhaGetArcFileSizeEx                書庫サイズの取得
        %w UnlhaGetArcOriginalSize              展開サイズの取得
        %w UnlhaGetArcOriginalSizeEx            展開サイズの取得
        %x UnlhaGetArcCompressedSize            圧縮サイズの取得
        %x UnlhaGetArcCompressedSizeEx          圧縮サイズの取得
        %y UnlhaGetArcRatio                     圧縮率の取得
        %z UnlhaGetArcDate                      書庫更新日の取得
        %A UnlhaGetArcTime                      書庫更新時間の取得
        %Q UnlhaGetArcCreateTime                書庫作成日時の取得
        %Q UnlhaGetArcCreateTimeEx              書庫作成日時の取得
        %Q UnlhaGetArcCreateTime64              書庫作成日時の取得
        %R UnlhaGetArcAccessTime                書庫参照日時の取得
        %R UnlhaGetArcAccessTimeEx              書庫参照日時の取得
        %R UnlhaGetArcAccessTime64              書庫参照日時の取得
        %S UnlhaGetArcWriteTime                 書庫更新日時の取得
        %S UnlhaGetArcWriteTimeEx               書庫更新日時の取得
        %S UnlhaGetArcWriteTime64               書庫更新日時の取得
        %B UnlhaGetArcOSType                    使用 OS の取得
        %C UnlhaIsSFXFile                       SFX タイプの取得
        %T UnlhaGetArcReadSize                  読み込みサイズの取得
        %T UnlhaGetArcReadSizeEx                読み込みサイズの取得
        %D UnlhaGetFileName                     ファイル名の取得
        %E UnlhaGetMethod                       メソッドの取得
        %F UnlhaGetOriginalSize                 サイズの取得
        %F UnlhaGetOriginalSizeEx               サイズの取得
        %G UnlhaGetCompressedSize               圧縮サイズの取得
        %G UnlhaGetCompressedSizeEx             圧縮サイズの取得
        %H UnlhaGetRatio                        圧縮率の取得
        %I UnlhaGetDate                         更新日の取得
        %J UnlhaGetTime                         更新時間の取得
        %K UnlhaGetWriteTime                    更新日時の取得
        %K UnlhaGetWriteTimeEx                  更新日時の取得
        %K UnlhaGetWriteTime64                  更新日時の取得
        %L UnlhaGetCreateTime                   作成日時の取得
        %L UnlhaGetCreateTimeEx                 作成日時の取得
        %L UnlhaGetCreateTime64                 作成日時の取得
        %M UnlhaGetAccessTime                   参照日時の取得
        %M UnlhaGetAccessTimeEx                 参照日時の取得
        %M UnlhaGetAccessTime64                 参照日時の取得
        %N UnlhaGetCRC                          チェックサムの取得
        %O UnlhaGetAttribute                    属性の取得
        %P UnlhaGetOSType                       使用 OS の取得

        その他の API

        %U UnlhaSetUnicodeMode                  使用コード設定
        %V UnlhaSetPriority                     優先度の設定
        %W UnlhaGetLastError                    エラーコードの取得

%2. 『統合アーカイバプロジェクト』対応 API について
%3. API で使用されている構造体について
%4. レジストリーの設定値
%5. Unlha()の返すエラーコードとその意味
%6. その他
  a : Unicode 対応化について
  b : メモリマップドファイルについて
  c : タイムスタンプの補正について
  d : Windows 及び MS-DOS で扱えない文字について
  e : UnlhaOpenArchive() 等のハンドルについて
-----------------------------------------------------------------------


-----------------------------------------------------------------------
%0. 概要。
-----------------------------------------------------------------------

　UNLHA32.DLL は， LHx Ver 2.02a を基に Windows 3.0A/3.1 用 DLL として移植
・開発された LHA.DLL を参考に， その API に準拠した上で若干の API を追加し
たものとして私が開発した UNLHA.DLL を， さらに Win32 用 DLL として移植した
ものです。

　元々，『LHA と同じ感覚でコマンドを渡して手軽に書庫を操作』することを目的
として開発されている関係上，『格納ファイル毎の個別処理』といった細かな操作
には向いていませんし，メモリーを対象とした操作や一定サイズごとの処理といっ
たものについても全く考慮されていません。これらの処理を行いたい場合には，無
理をして UNLHA32.DLL を使用するよりも， 別途専用のルーチンを作成したほうが
労力も時間も節約できると思います。

　API の体系については， 大まかに言えば，Unlha() をはじめとした LHA.DLL 互
換の API 群，UnlhaOpenArchive() をはじめとした書庫や格納ファイルの情報を得
るための OpenArchive 系 API， 対応アプリ側での進捗表示等を行うのに必要な情
報を得るための SetOwnerWindow 系 API に分かれています。


-----------------------------------------------------------------------
%1. 各 API の説明。
-----------------------------------------------------------------------

　C 形式となっていますので，C++ から使用する場合は extern "C" で宣言・使用
するようにしてください。また，UNLHA32.DLL が使用する構造体については，すべ
てワードアラインメントをオフにしておく必要があります。

　UNLHA32.H を使用する場合は， Microsoft Visual C++，Borland C++， Borland
C++ Builder 等のコンパイラーであれば，改めて設定を行う必要がありません。

　整数データについては以下のサイズで扱われます：

        char         8 ビット (unsigned)
        short       16 ビット
        WORD        16 ビット (unsigned)
        WCHAR       16 ビット (unsigned)
        int         32 ビット
        long        32 ビット
        DWORD       32 ビット (unsigned)
        LONGLONG    64 ビット

-----------------------------------------------------------------------
LHA.DLL 互換 API
-----------------------------------------------------------------------

　LHA.DLL 互換の API です。『概要』でも記述したとおり，コマンドライン・ツー
ル的な仕様となっているため， 細かな書庫操作には向きません。 若干の追加 API
が存在します。

-----------------------------------------------------------------------
%a      WORD WINAPI UnlhaGetVersion(
                        VOID
                    )
-----------------------------------------------------------------------
順序数  2
要求版  0.01
機能
        UNLHA32.DLL のバージョンを返します。

戻り値
        単純に言えば，次のごとく版数に 100 を掛けたものが返ってきます。

                DLL のバージョン | 戻り値
                -----------------+--------
                0.01             |      1
                1.45             |    145

        また， この数値はリソースのバージョン情報の上位 2 ワードとも関連し
        ています。下位 2 ワードを得るには，UnlhaGetSubVersion() を使用しま
        す (Ver 0.20 以降)。

                リソース情報     | 戻り値
                -----------------+--------
                1.45.1.2         |    145

        版数については明確な取り決めはありませんが，一応 UNLHA32.DLL では：

                1.45.1.2 | a : メジャーバージョン。ほとんど意味なしです。
                a.bc.d.e | b : API  の追加や仕様変更の際には必ずインクリメ
                         |     ントされます。
                         | c : 改版のたびにインクリメントされます。 返却値
                         |     の仕様から， 10 回改版されれば API の変更等
                         |     にかかわらず b のほうもインクリメントされる
                         |     結果となることに注意してください。
                         | d : 修正バージョンやβ版等， 改版に満たない修正
                         |     版の際にインクリメントされます。 ドキュメン
                         |     ト等で 1.45a となっていれば  a の部分を表し
                         |     ます。b なら 2 となります。
                         | e : 版においてのパッチレベル。レベルが 100 を超
                         |     えると d が一つインクリメントされます。

        といった感じになっています。が，この仕様どおりに版数が進行していな
        いことも多々あります。(^^;)

その他
        仕様変更等への対応を考慮して，バージョンのチェックを推奨します。
        後述するレジストリーの UnlhaVersion 等を設定することで返却値を変更
        することができます。

-----------------------------------------------------------------------
%b      BOOL WINAPI UnlhaGetRunning(
                        VOID
                    )
-----------------------------------------------------------------------
順序数  10
要求版  0.01
機能
        現在 UNLHA32.DLL が動作中 (API 実行中) か否かを得ます。UNLHA32.DLL
        は同一インスタンスからの複数同時実行に対応していないので，同時に実
        行される可能性がある場合は，アプリ側で  API を呼び出す前にチェック
        を行うようにしてください。 一応 UNLHA32.DLL 側でも処理を行う前に内
        部でこのチェックを行ってはいます。

戻り値
        動作中 (API を実行中)   TRUE を返します。新たに API を実行すること
                                は出来ません。
        非動作中                FALSE を返します。API の実行が可能です。

注意
        初期の版では， この UnlhaGetRunning() においてさえメッセージループ
        をまわしていましたが，現在ではまわさないようになっています。

        これは，対応アプリ側での動作チェック時に，単純に：

            while (UnlhaGetRunning()) {
                ;
            }

        のようなループで DLL の終了待ちをしてしまっているため， 環境によっ
        ては (Win32s ではほぼ確実に)  無限ループに陥ってしまう――という状
        況が結構見られたために，過去において付加された処理です。

        本来， このような単純な API においてループをまわすことは好ましくな
        いことから，先に書いたように現在ではループをまわさないようになって
        いるわけですが，未だに上記のような無限ループに陥ってしまうアプリが
        まれに存在します。

        そのようなアプリに遭遇した場合には， レジストリーの CauseLoop を 1
        に設定してください。特定用途向けのアプリでもない限り，一般のアプリ
        においては， この API でメッセージループをまわしても大きな問題はな
        いと思います。とはいうものの，DLL を呼び出している間にメッセージ
        ループがまわらないことを期待して，ウィンドウ周りの処理を手抜きして
        いるアプリも多々見受けられるのですが…。この辺りについては，後述の
        UnlhaSetBackGroundMode() の項も参照してください。

-----------------------------------------------------------------------
%c      BOOL WINAPI UnlhaGetBackGroundMode(
                        VOID
                    )
-----------------------------------------------------------------------
順序数  5
要求版  0.01
機能
        UNLHA32.DLL がバックグラウンドモードか否かを得ます。バックグラウン
        ドモードの意味については，次の UnlhaSetBackGroundMode() の説明を参
        照してください。

戻り値
        バックグラウンドモード          TRUE を返します。
        非バックグラウンドモード        FALSE を返します。

-----------------------------------------------------------------------
%d      BOOL WINAPI UnlhaSetBackGroundMode(
                        const BOOL  _bBackGroundMode
                    )
-----------------------------------------------------------------------
順序数  6
要求版  0.01
機能
        UNLHA32.DLL のバックグラウンドモードを設定します。

引数
        バックグラウンドモードとする場合は TRUE を渡します。
        非バックグラウンドモードとする場合は FALSE を渡します。

戻り値
        正常終了        TRUE を返します。
        異常終了        動作中で変更できなかった場合や，引数が間違いの場合
                        には FALSE を返します。 実際のエラーコードを得るに
                        は UnlhaGetLastError() API を使用してください。

注意
        Ver 1.30〜1.95a までの版では設定に関わらず同じ動作を行うようになっ
        ていて，非バックグラウンドモードであっても，一定の割合でメッセージ
        ループが回されます。それより前の版では，フォアグラウンドモードにつ
        いては，UNLHA32.DLL が明示的にメッセージループを回すことはありませ
        ん。

        Ver 1.95b 以降では，メッセージループに関する処理に変更はありません
        が，優先度処理の追加により，バックグラウンドモードと非バックグラウ
        ンドモードでの動作が再び異なっている点に注意して下さい。  バックグ
        ラウンドモードが指定されている場合， UnlhaSetPriority() で THREAD_
        PRIORITY_NORMAL 以上の優先度が指定されている場合でも， Sleep() API
        使用によるウェイトが入ります。

        ここでの『バックグラウンドモード』とは，一般的な意味ではなく，
        『UNLHA32.DLL が動作中にメッセージループをまわす』という意味です。
        LHA.DLL が，通常 (フォアグラウンドモード) においてはメッセージルー
        プを一切まわさず，結果として LHA.DLL  の動作中はシステムがストップ
        する (当時の Windows 3.0A/3.1 環境では，プログラムが明示的に処理を
        他のタスクに明け渡す必要がありました)…というものだったので， 「他
        のタスクに処理を明け渡す」という意味での『バックグラウンドモード』
        を指定できるようになっています。

        先に説明したように，この API で FALSE を指定した場合でも，必要最低
        限の頻度でメッセージループをまわすようになっています。従って，完全
        に処理時間を占有させることはできません。古いソフトなど，LHA.DLL 互
        換の動作を想定しているプログラムでは問題の出る可能性がありますので，
        注意してください。

        例えば，LHA.DLL の使用を前提としたアプリでは，フォアグラウンドモー
        ドにおいて  DLL の動作が終了しない限り処理が戻ってこないことを利用
        して，ウィンドウの Enable/Disenable 等や共有関係の処理を省略してい
        るものがありますが，UNLHA32.DLL を使用する場合，そのようなアプリで
        は問題が発生します。

        問題の発生するソフトを使用する場合など，あえて明示的に一切メッセー
        ジループを回さないよう指定したい場合は，"-jsb"  スイッチ及び M_NO_
        BACKGROUND_MODE を使用してください。ただし，メッセージループを回さ
        ないことから，たとえ状況表示ダイアログを表示していたとしても，『中
        止』ボタンが機能しなかったり，環境によってはダイアログの更新すら行
        われないことがありますので，注意が必要となります。

-----------------------------------------------------------------------
%e      BOOL WINAPI UnlhaGetCursorMode(
                        VOID
                    )
-----------------------------------------------------------------------
順序数  7
要求版  0.01
機能
        UNLHA32.DLL の動作中に独自カーソルを表示するモードか否かを得ます。

戻り値
        カーソル表示モード      TRUE を返します。
        カーソル非表示モード    FALSE を返します。

-----------------------------------------------------------------------
%f      BOOL WINAPI UnlhaSetCursorMode(
                        const BOOL  _CursorMode
                    )
-----------------------------------------------------------------------
順序数  8
要求版  0.01
機能
        UNLHA32.DLL の動作中に独自カーソルを表示するか否かを設定します。

引数
        カーソルを表示するのであれば TRUE を渡します。
        カーソルを表示しないのであれば FALSE を渡します。

戻り値
        正常終了時      TRUE を返します。
        エラー時        動作中で変更できなかった場合や，引数が間違いの場合
                        には FALSE を返します。 実際のエラーコードを得るに
                        は UnlhaGetLastError() API を使用してください。

その他
        LHA.DLL の様な回転カーソルはサポートしていないので，実際は独自の時
        計カーソルを表示するか否かの設定となります。 また，TRUE を渡した場
        合，LHA.DLL と異なり，フォアグラウンドモードにおいてもカーソルが表
        示されます。

-----------------------------------------------------------------------
%g      WORD WINAPI UnlhaGetCursorInterval(
                        VOID
                    )
-----------------------------------------------------------------------
順序数  3
要求版  0.01
機能
        独自カーソルの回転速度を得ます

戻り値
        カーソルの回転速度（msec)

その他
        呼び出してもエラーとはなりませんが，回転カーソルをサポートしていな
        いので無意味です。

-----------------------------------------------------------------------
%h      BOOL WINAPI UnlhaSetCursorInterval(
                        const WORD  _Interval
                    )
-----------------------------------------------------------------------
順序数  4
要求版  0.01
機能
        独自カーソルの回転速度を設定します。 UNLHA32.DLLの動作中には変更で
        きません。

引数
        カーソルの回転速度（msec)
        既定値は 80 (msec) です。

戻り値
        正常終了時      TRUE を返します。
        エラー時        動作中で変更できなかった場合や，引数が間違いの場合
                        には FALSE を返します。 実際のエラーコードを得るに
                        は UnlhaGetLastError() API を使用してください。

その他
        エラーにはなりませんが，回転カーソルをサポートしていないので設定は
        無意味です。一応設定値は記憶するようになっています。

参考
        『回転カーソル』とは，LHA.DLL が使用していたアニメカーソルのことで
        す。LHA.DLL でも動作中を表すために実行の際に専用カーソルを表示して
        いましたが (って，そっちが本家)， それがアニメカーソルだったわけで
        す。

        当時の環境では，タイマーを使って適当なタイミングでカーソルを切り替
        える方法しかなかったわけですが，その切り替えタイミングを設定するの
        が，この API だったわけです。 さらに，このタイマー処理に伴うタスク
        切り替え発生が，バックグラウンドモードの実体でもあったため，ここで
        の設定が，処理速度に直結していました。(^^;)

-----------------------------------------------------------------------
%i      int WINAPI Unlha(
                       HWND         _hwnd,
                       LPCTSTR      _szCmdLine,
                       LPTSTR       _szOutput,
                       const DWORD  _dwSize
                   )
-----------------------------------------------------------------------
順序数    1 : Unlha
        301 : UnlhaA
        601 : UnlhaW
要求版  Unlha  : 0.01
        UnlhaA : 2.39a
        UnlhaW : 2.40
機能
        LHA 互換のコマンド文字列を与えて各種の書庫操作を行います。基本的に，
        コマンドラインツールである LHA を DLL として呼び出すようなものであ
        ることから，細かな書庫操作には向きませんが，LHA にある程度慣れてい
        ると， 非常にお手軽で便利な API だったりします。
        従って，COMMAND.TXT 等のドキュメントが存在するものの，LHA の知識は
        依然として必須となっています。

引数
        _hwnd       UNLHA32.DLL を呼び出すアプリのウィンドウ・ハンドル。
                    UNLHA32.DLL は実行時にこのウィンドウに対して EnableWin-
                    dow() を実行しウィンドウの動作を抑制します。ウィンドウ
                    が存在しないコンソールアプリの場合や，指定する必要のな
                    い場合は NULL を渡します。後述の API で EnableWindow()
                    の対象ウィンドウを変更することもできます。
        _szCmdLine  UNLHA32.DLL に渡すコマンドの文字列。MS-DOS 版の LHA と
                    同様のものが指定できます。ただし，ARJ のように展開ファ
                    イル毎にスイッチを指定するようなことはできません。
                    ここで指定するコマンド等については  COMMAND.TXT で詳述
                    されています。
        _szOutput   UNLHA32.DLL が結果を返すためのバッファ。LHA がコンソー
                    ルに表示するものと同様の出力が，このバッファに格納され
                    ます。ここで指定するバッファについては，_dwSize で示さ
                    れるサイズが保証されている必要があります。
                    ログが必要ない場合は NULL を渡すことができます。
        _dwSize     TCHAR 単位で示されたバッファのサイズ。UNLHA32.DLL が返
                    す結果のサイズより指定されたサイズが小さい場合は指定サ
                    イズまで出力されます。

戻り値
        正常終了時      0。
        エラー時        0 以外の数が返されます。エラーコードと意味について
                        は，このドキュメントの項目 5 を参照してください。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

注意
        "-jsc" スイッチが指定されたときなど，正常終了している場合でも，
        Unlha() が 0 以外の数を返す場合があります。 実際のエラーコードを得
        るには UnlhaGetLastError() API を使用してください。

        Ver 1.45 以降では出力されるログの改行文字が  "\n" から "\r\n" に変
        更されています。このため，一部のアプリでは正常にログが取り込めなく
        なっています。暫定措置として， GV から呼び出された場合には強制的に
        旧仕様である "\n" の改行を行うようになっています (Ver 1.52a 以降)。

簡単なコマンド例

        a c:\arc\archive.lzh -x1r2a2 c:\ data
            　c:\data ディレクトリーをサブディレクトリーも含めてすべて格納。

        e c:\arc\archive.lzh -x1a1 -c c:\ *.*
            　ディレクトリー構造を再構築しながら c:\ 上に展開。

        e c:\arc\archive.lzh -a1 -c -p c:\text\ readme.txt
            　c:\text に readme.txt を展開。

        d c:\arc\archive.lzh *.*
            　格納ファイルをすべて削除 (結果書庫も削除される)。

        s c:\arc\archive.lzh -gw3 c:\sfx\
            　書庫を変換して c:\sfx に WinSFX32M (archive.exe) を作成。

-----------------------------------------------------------------------
以降は LHA.DLL 互換ではありません。
-----------------------------------------------------------------------
%j      BOOL WINAPI UnlhaCheckArchive(
                        LPCTSTR    _szFileName,
                        const int  _iMode
                    )
-----------------------------------------------------------------------
順序数   11 : UnlhaCheckArchive
        311 : UnlhaCheckArchiveA
        611 : UnlhaCheckArchiveW
要求版  UnlhaCheckArchive  : 0.01
        UnlhaCheckArchiveA : 2.40
        UnlhaCheckArchiveW : 2.40
機能
        指定ファイルが書庫として正しいかどうかを返します。

引数
        _szFileName     チェックすべき書庫のファイル名。
        _iMode          チェックモード。
          CHECKARCHIVE_RAPID    簡易モード。 格納ファイルの CRC チェックは
                (0)             行わず，ヘッダのみチェックします。このモー
                                ドは FDD  上の書庫ファイル等で処理に時間が
                                掛かるのを防ぐため， 最初から 3 つ目までの
                                ファイルヘッダについてのみチェックを行いま
                                す。また， ファイルの先頭 128KB まででヘッ
                                ダが見つからなかった場合は，そこで検索を打
                                ち切ります (非書庫扱い)。
                                すべてのヘッダを読み込まないことから， LZH
                                書庫が含まれた ZIP  書庫…といった入れ子の
                                場合にも正常な  LZH 書庫として認識してしま
                                う点に注意してください。
          CHECKARCHIVE_BASIC    通常モード。簡易モードと異なり，こちらは全
                (1)             てのヘッダについてチェックします。ただし，
                                LZH 書庫の仕様上，ファイル全体を読み込むこ
                                とになりますので，巨大な書庫ではチェックに
                                多くの時間が掛かることになります。
          CHECKARCHIVE_FULLCRC  厳密モード。 格納ファイルの CRC もチェック
                (2)             します。ファイルが書き込まれないだけで展開
                                時と同様の処理が行われることから，通常モー
                                ドよりさらに長大な処理時間を要することにな
                                ります。

          　以下のフラグは上記のフラグと組み合わせて使います。

          CHECKARCHIVE_RECOVERY 破損ヘッダを無視。このフラグを指定すると，
                (4)             破損ヘッダやハフマンコードエラーを無視して，
                                それ以降の格納ファイルへのアクセスが可能に
                                なります。
                                Unlha() 等による本処理の際に，破損ヘッダを
                                無視させたい場合に指定するのが基本となりま
                                す。そうでない場合は指定すべきではありませ
                                ん。
          CHECKARCHIVE_SFX      自己解凍書庫かどうかを確認。通常においては
                (8)             書庫と認識された場合には TRUE を返しますが，
                                このフラグを指定すると，自己解凍書庫と認識
                                された場合に自己解凍書庫の種類をあらわす数
                                値を返します。
          CHECKARCHIVE_ALL      CHECKARCHIVE_RAPID を指定した場合に， ヘッ
                (16)            ダ検索をファイルのすべての領域について行い
                                たい場合に指定します。検索が最後まで行われ
                                るだけで， チェックされるヘッダが 3 つのま
                                まである点に変わりはないので注意してくださ
                                い。
          CHECKARCHIVE_ENDDATA  書庫のうしろの余剰データを許可する。通常，
                (32)            UNLHA32.DLL は入れ子の書庫等の誤認識を避け
                                るために， 他書庫に内包された LZH 書庫であ
                                ると想定された場合には書庫として扱いません
                                が，このフラグを指定すると，そのようなもの
                                についても正常な書庫として扱うようになりま
                                す。

戻り値
        LZH ファイルの時        FALSE 以外。通常は TRUE を返します。書庫が
                                自己解凍書庫の場合で， かつ  CHECKARCHIVE_
                                SFX が指定された場合は，後述する  UnlhaIs-
                                SFXFile() の返却値に 0x8000 を加えた数値を
                                返します。
        ファイルが不正の時      FALSE。 LZH 書庫でなかった場合だけでなく，
                                書庫が壊れていたり単にヘッダを見つけられな
                                かっただけの場合も  FALSE を返すことに注意
                                が必要となります。実際のエラーコードを得る
                                には  UnlhaGetLastError() API を使用してく
                                ださい。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

その他
        CHECKARCHIVE_RECOVERY は，この API としては不適当なものですが "-jc"
        スイッチ付きで破損ヘッダのある書庫の展開等を行いたい場合のために存
        在するものです。 Unlha() でそのような書庫を扱いたいのに， 書庫種別
        判定などの目的で事前に行われるであろう UnlhaCheckArchive() で『LZH
        書庫ではない』と判断されたのでは困りものなので…。(^^;)

        この API の仕様から予想できると思いますが， 壊れた書庫や単にヘッダ
        が見つからなかった書庫についても単純に FALSE を返します。 従って，
        書庫以外のファイルと壊れた書庫とのどちらであるかを判断したい場合は，
        基本的には，  一旦  CHECKARCHIVE_RAPID  でチェックした後に  CHECK-
        ARCHIVE_FULLCRC で再度チェックを行う…等の複数回のチェックが必要と
        なります。それでもヘッダが壊れていた場合には判断できない場合があり
        ますが…。 比較的最近の版であれば UnlhaGetLastError() API を使用す
        ることもできます。

注意
        自己解凍書庫については，書庫自体に自己解凍書庫であることを示すフラ
        グやバージョン等の情報が存在するわけではありませんので，自己解凍書
        庫のバージョンによっては正しく認識できない場合があります。

-----------------------------------------------------------------------
%k      int WINAPI UnlhaGetFileCount(
                       LPCTSTR  _szArcFile
                   )
-----------------------------------------------------------------------
順序数   17 : UnlhaGetFileCount
        317 : UnlhaGetFileCountA
        617 : UnlhaGetFileCountW
要求版  UnlhaGetFileCount  : 0.01
        UnlhaGetFileCountA : 2.39a
        UnlhaGetFileCountW : 2.40
機能
        指定された書庫ファイルに格納されているファイル数を得ます。

引数
        _szArcFile      格納ファイル数を得たい書庫ファイル名。

戻り値
        正常終了時      格納ファイル数が返されます。
        エラー時        -1 が返されます。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

その他
        内部的には  CHECKARCHIVE_BASIC モードで UnlhaCheckArchive() を呼び
        出しています。(^^;)

-----------------------------------------------------------------------
%l      BOOL WINAPI UnlhaQueryFunctionList(
                        const int  _iFunction
                    )
-----------------------------------------------------------------------
順序数  18
要求版  0.01
機能
        指定された API が使用可能かどうかを得ます。

引数
        _iFunction      API を示す一様な数値。具体的な数値については UNLHA-
                        32.H を参照して下さい。

戻り値
        API が使用可能ならば TRUE を返し，使用不能ならば FALSE を返します。
        _iFunction に無効な値を渡した場合も FALSE を返します。

注意
        Unlha()/UnlhaW()/UnlhaA() など，Unicode 版と ANSI 版を個別に判定す
        ることは出来ません。 Unicode 版は一律 Ver 2.40  以降で使用が可能と
        なっています。

-----------------------------------------------------------------------
%m      BOOL WINAPI UnlhaConfigDialog(
                        HWND        _hwnd,
                        LPTSTR      _szOptionBuffer,
                        const int   _iMode
                    )
-----------------------------------------------------------------------
順序数   12 : UnlhaConfigDialog
        312 : UnlhaConfigDialogA
        612 : UnlhaConfigDialogW
要求版  UnlhaConfigDialog  : 0.01
        UnlhaConfigDialogA : 2.39a
        UnlhaConfigDialogW : 2.40
機能
        基準ディレクトリーやスイッチが指定されなかった場合の既定動作を指定
        する設定ダイアログを呼び出します。指定可能なものは：

          1:　展開時の基準ディレクトリー。また，その設定したディレクトリー
            を有効にするかどうか。
          2:　ディレクトリーについて，相対パスとするか絶対パスとするかの指
            定。(-jf0 | -jf1)
          3:　不正パスチェックのチェックレベルの指定。(-jsp0 | -jsp1 |
            -jsp3)
          4:　上書き時の動作。(-jyo1 | -jyo0 | -c -jn)
          5:　属性を復元するかどうか。(-a0 | -a1)
          6:　ディレクトリー作成時の確認をするかどうか。(-jyc0 | -jyc1)
          7:　展開先のディスクの空きがあるかを確認するかどうか。(-f0 | -f1)
          8:　メンバーのパス情報を有効とするかどうか。(-gj0 | -gj1)
          9:　進捗グラフの表示方法。(-gn0 | -gn1)
         10:　簡易ダイアログで展開状況を表示するかどうか。(-gn2)
         11:　ログ出力の改行コードについて， '\n' を使用するか "\r\n" を使
            用するかの選択。
         12:　ファイルの入出力にメモリマップドファイルを使用するかどうか。

        です。実際にダイアログを開いてみて，その上で STRTABLE.TXT の該当の
        文字列に関する説明文を参照すると理解しやすいと思います。

引数
        _hwnd           ダイアログのオーナー・ウィンドウのハンドル。
        _szOptionBuffer レジストリーに書き込まれる内容と同様の動作を行う為
                        のコマンド文字列を得るためのバッファのポインタ。用
                        意するバッファは 513 バイト (Unicode 版では 513 文
                        字) 以上を確保してください。
        _iMode          展開時と格納時のどちらについてのものかを指定します。
                        ただし，UNLHA32.DLL ではこの指定は無視されます。

          UNPACK_CONFIG_MODE    1       展開時についてのスイッチを指定。
          PACK_CONFIG_MODE      2       格納時についてのスイッチを指定。

戻り値
        正常終了時      TRUE が返されます。
        エラー時        ユーザが取消終了した場合を含めて，エラー時には
                        FALSE  が返されます。 実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

参考
        UnlhaConfigDialog() が返すコマンド列には，この後で説明する Extract-
        Attribute 及び RegardECommand の設定は含まれません。また，ダイアロ
        グで指定した基準ディレクトリーはコマンド列には含まれません。

その他
        設定は レジストリーの Software\ArchiverDll 以下に書き込まれます。
        アーカイバー DLL 間で共通に使われる Archiver\Common 内で設定される
        オプションについては， UNARJ32.DLL 等他のアーカイバー DLL での設定
        の影響を受けますし，反対に，それらの DLL の動作に影響を及ぼします。
        UNLHA32.DLL は明示的に展開先ディレクトリーやスイッチが指定されな
        かった場合に，もしレジストリーに該当の省略値が設定されていればそれ
        を使用します。コマンドラインで明示的に指定された場合は，コマンド指
        定が優先的に使用されます。レジストリーにも指定されていない場合は，
        UNLHA32.DLL 本来のデフォルトの動作となります。UNLHA32.DLL にレジス
        トリーの設定を使わないようにさせるには "-+" スイッチを指定して下
        さい。
        なお，UnlhaConfigDialog() が返すコマンド列には "-+" スイッチが含ま
        れています。

        なお， 3 の不正パスチェックについては，"-+" スイッチの有無にかかわ
        らずレジストリーの値が適用されます。

注意
        設定ダイアログでの設定の結果，UNLHA32.DLL 対応アプリが期待どおりの
        動作をしなくなる恐れのある設定項目については，次のものがあります：

        1:  基準ディレクトリー
          　Unlha() 等で基準ディレクトリーが指定されない場合に，ここで設定
          されたディレクトリーが基準ディレクトリーとして使用されるため，対
          応アプリが『カレント・ディレクトリー』を意図してディレクトリーを
          指定しなかった場合に，意図しないディレクトリー上のファイルが処理
          される可能性があります。
        2:  絶対パスの扱い (相対パス)
          　「相対パス」が選択されていると，ルート・ディレクトリーからの再
          構築が意図された書庫の展開が正常に行われなくなります。絶対パスで
          の圧縮・格納を行っているアプリが意外と多いという事実から，この設
          定には注意が必要です。
        3:  不正パスチェック (Level 1・Level 2)
          　『Level 1』以上の場合は， 展開先としてルートディレクトリーを指
          定していない限り，絶対パスで格納されたファイルの展開を行えません。
          必ず処理選択を求められます。そのため，絶対パスでの格納を前提とし
          た処理を行うアプリで，不具合のでる可能性があります。
        4:  上書き時の確認 (常に上書き・上書きしない)
          　ここの設定の結果，アプリが意図していない「常時上書き」「常時展
          開中止」の発生する可能性があります。
        8:  ディレクトリー構造を無視
          　ここがチェックされていると，ディレクトリー構造を認識・再構築さ
          れないことになります。
        9:  合計でグラフ表示
          　LZH 書庫が，書庫自身の情報ヘッダやインデックス情報ヘッダをもた
          ないことから，合計を得るためには一旦書庫すべてを検索することにな
          ります。この結果書庫を二度読みすることになり，展開時の処理時間が
          倍増してしまいます。
       10:  旧式ログ出力
          　UNLHA32.DLL Ver 1.45 以降では， ログ出力の改行コードに  "\r\n"
          を使用するように仕様変更されていますが，一部のソフトにおいては従
          来の "\n" でないと正常に動作しません。初心者等のとりあえずの回避
          用にこの項目を用意してありますが，ソフトにかかわらず設定が適用さ
          れるため，反対に動作しなくなるソフトが出てくる可能性が考えられま
          す (特に Ver 1.45 公開以降に作成された対応ソフト)。
       12:  メモリマップドファイルの使用
          　メモリマップドファイルを使用している場合，UNLHA32.DLL は書き込
          みに伴うファイルのサイズ拡張を 8MB 単位で行うことから， 書き込み
          先の空き容量が少ない場合に， (本来収まるはずのものが) 書き込みエ
          ラーの発生してしまうことがあります。

-----------------------------------------------------------------------
%o      int WINAPI UnlhaExtractMem(
                       HWND         _hwnd,
                       LPCTSTR      _szCmdLine,
                       LPBYTE       _szBuffer,
                       const DWORD  _dwSize,
                       time_t *     _lpTime,
                       LPWORD       _lpwAttr,
                       LPDWORD      _lpdwWriteSize
                   )
-----------------------------------------------------------------------
順序数   49 : UnlhaExtractMem
        349 : UnlhaExtractMemA
        649 : UnlhaExtractMemW
要求版  UnlhaExtractMem  : 0.60
        UnlhaExtractMemA : 2.39a
        UnlhaExtractMemW : 2.40
機能
        メモリーバッファへ展開します。 残念ながら， _lpdwWriteSize で指定
        したサイズごとに複数回に分けて処理…といった使用法は行えません。

引数
        _hwnd       UNLHA32.DLL を呼び出すアプリのウィンドウのハンドル。
                    UNLHA32.DLL は実行時にこのウィンドウに対して EnableWin-
                    dow() を実行しウィンドウの動作を抑制します。ウィンドウ
                    が存在しないコンソールアプリの場合や，指定する必要のな
                    い場合は NULL を渡します。
        _szCmdLine  UNLHA32.DLL に渡すコマンドの文字列。Unlha() と同じもの
                    が指定できますが，コマンドは無視されます。
        _lpBuffer   展開イメージを格納するバッファ。ここで指定するバッファ
                    については，_dwSize で示されるサイズが保証されている必
                    要があります。
        _dwSize     バッファのサイズ。UNLHA32.DLL が返す結果のサイズより指
                    定されたサイズが小さい場合は指定サイズまで出力されます。
        _lpTime     展開されたファイルの UTC でのタイムスタンプを得ます。
                    必要ない場合は NULL を指定します。
        _lpwAttr    展開されたファイルの属性を得ます。 必要ない場合は NULL
                    を指定します。
        _lpdwWriteSize
                    展開の結果書き込まれたサイズを得ます。  必要ない場合は
                    NULL を指定します。

戻り値
        正常終了時      0。
        エラー時        0 以外の数が返されます。エラーコードと意味について
                        は，このドキュメントの項目 5 を参照してください。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

その他
        API の性格上，書庫やファイル名にワイルドカードを使うのは無意味と思
        われます。

-----------------------------------------------------------------------
%p      int WINAPI UnlhaCompressMem(
                       HWND            _hwnd,
                       LPCTSTR         _szCmdLine,
                       const LPBYTE    _szBuffer,
                       const DWORD     _dwSize,
                       const time_t *  _lpTime,
                       const LPWORD    _lpwAttr,
                       LPDWORD         _lpdwWriteSize
                   )
-----------------------------------------------------------------------
順序数   50 UnlhaCompressMem
        350 UnlhaCompressMemA
        650 UnlhaCompressMemW
要求版  UnlhaCompressMem  : 0.01
        UnlhaCompressMemA : 2.39a
        UnlhaCompressMemW : 2.40
機能
        メモリーバッファの内容を圧縮して書庫に格納します。残念ながら，メモ
        リー上に書庫を作成するわけではありません。

引数
        _hwnd       UNLHA32.DLL を呼び出すアプリのウィンドウのハンドル。
                    UNLHA32.DLL は実行時にこのウィンドウに対して EnableWin-
                    dow() を実行しウィンドウの動作を抑制します。ウィンドウ
                    が存在しないコンソールアプリの場合や，指定する必要のな
                    い場合は NULL を渡します。
        _szCmdLine  UNLHA32.DLL に渡すコマンドの文字列。ファイル名として指
                    定したものが格納時の名前になります。
        _lpBuffer   圧縮するイメージを格納したバッファ。
        _dwSize     イメージのサイズ。
        _lpTime     格納する時刻を UTC で指定します。NULL を指定すると格納
                    を行った時点の時刻が使用されます。
        _lpwAttr    格納する属性を指定します。NULL を指定すると FA_ARCH と
                    みなされます。
        _lpdwWriteSize
                    圧縮後のサイズを得ます。必要ないときは NULL を指定しま
                    す。

戻り値
        正常終了時      0。
        エラー時        0 以外の数が返されます。エラーコードと意味について
                        は，このドキュメントの項目 5 を参照してください。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

その他
        API の性格上，書庫やファイル名にワイルドカードを使うのは無意味と思
        われます。


--------------------------------------------------------------------------
OpenArchive 系 API
--------------------------------------------------------------------------

　『Unlha() での 'l'  命令等の出力ログを利用しての情報取得』では不便なこと
から，UNARJ.DLL において，書庫情報取得用として追加された API 群です。UNARJ.
DLL では UnarjExtract() 等， OpenArchive 系 API での検索・情報取得に従って
各種の処理を行う  API が用意される予定でした。 これは現在の SetEnumMember-
Proc() 系 API よりもはるかに便利で細かい処理が可能なはずのものだったのです
が，ARJ ということもあって反響が全くなく，UNARJ.DLL 以外には実装すらされな
かったという不運な API 群です。近年，それらの API で行えるような処理につい
ての要望の多いのが皮肉ではあります。(^^;;

　経緯はともかく，UNLHA32.DLL では情報取得系の API しか実装されていません。

　OpenArchive 系の API は， 上記で説明した Unlha 系の API との混在はできま
せんので注意してください。ここで言う『混在』とは， UnlhaOpenArchive() で書
庫を開いて再び UnlhaCloseArchive() で書庫を閉じるまでの間に Unlha() で別の
書庫を処理する…といったような処理のことです。

　OpenArchive 系での大まかな処理の流れは次のようになります。

      UnlhaOpenArchive();
      if (UnlhaFindFirst() != -1) {
          do {
              …
              構造体か，各種 API で情報を取得。API が望ましい。
              …
          } while (UnlhaFindNext() != -1);
      }
      UnlhaCloseArchive();

-----------------------------------------------------------------------
%q      HARC WINAPI UnlhaOpenArchive(
                        HWND         _hwnd,
                        LPCTSTR      _szFileName,
                        const DWORD  _dwMode
                    )
-----------------------------------------------------------------------
順序数   21 : UnlhaOpenArchive
        321 : UnlhaOpenArchiveA
        621 : UnlhaOpenArchiveW
要求版  UnlhaOpenArchive  : 0.01
        UnlhaOpenArchiveA : 2.39a
        UnlhaOpenArchiveW : 2.40
機能
        ハンドルと書庫ファイルを結び付けます。

引数
        _hwnd           UNLHA32.DLL を呼び出すアプリのウィンドウのハンドル。
        _szFileName     書庫ファイル名。
        _dwMode         UnlhaFindFirst() 等の処理のモード。

                        M_INIT_FILE_USE         レジストリーの設定を利用。
                        M_REGARDLESS_INIT_FILE  レジストリーの設定を無視。
                                                "-+" と同じです。
                        M_NO_BACKGROUND_MODE    メッセージループを回さない
                                                ようにします。("-jsb")
                        M_CHECK_ALL_PATH        ファイル名の検索時に全パス
                                                を使用して検索します。
                                                ("-p")
                        M_CHECK_FILENAME_ONLY   検索時にファイル名のみを対
                                                象とします。("-p-")
                        M_USE_DRIVE_LETTER      格納ファイルのディレクト
                                                リー情報について，絶対パス
                                                を示すルートディレクトリー
                                                のセパレータも利用します。
                                                ("-jf")
                        M_NOT_USE_DRIVE_LETTER  格納ファイルのルートディレ
                                                クトリー情報を無視します。
                        M_RECOVERY_ON           破損ヘッダを無視して，以降
                                                の格納ファイルにアクセスで
                                                きるようにします。("-jc")
                        M_ERROR_MESSAGE_ON      エラー時にメッセージを表示
                                                します。("-gm-")
                        M_ERROR_MESSAGE_OFF     エラー時にメッセージを表示
                                                しません。("-gm")

戻り値
        正常終了時      指定の書庫ファイルに対応したハンドルが返されます。
        エラー時        NULL を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

注意
        現バージョンでは，同時に複数のハンドルを利用する事はできません。
        Unlha() 等のルーチンを利用している関係上，グローバル変数を使いまくっ
        ているので…。

-----------------------------------------------------------------------
%q      HARC WINAPI UnlhaOpenArchive2(
                        HWND         _hwnd,
                        LPCTSTR      _szFileName,
                        const DWORD  _dwMode,
                        LPCTSTR      _szOption
                    )
-----------------------------------------------------------------------
順序数  112 : UnlhaOpenArchive2
        412 : UnlhaOpenArchive2A
        712 : UnlhaOpenArchive2W
要求版  UnlhaOpenArchive2  : 1.70
        UnlhaOpenArchive2A : 2.39a
        UnlhaOpenArchive2W : 2.40
機能
        ハンドルと書庫ファイルを結び付けます。 基本的に UnlhaOpenArchive()
        と同じですが， さらに Unlha() と同様のスイッチを指定することができ
        ます。

引数
        _hwnd           UNLHA32.DLL を呼び出すアプリのウィンドウのハンドル。
        _szFileName     書庫ファイル名。
        _dwMode         UnlhaFindFirst() 等の処理のモード。

                        M_INIT_FILE_USE         レジストリーの設定を利用。
                        M_REGARDLESS_INIT_FILE  レジストリーの設定を無視。
                                                "-+" と同じです。
                        M_NO_BACKGROUND_MODE    メッセージループを回さない
                                                ようにします。("-jsb")
                        M_CHECK_ALL_PATH        ファイル名の検索時に全パス
                                                を使用して検索します。
                                                ("-p")
                        M_CHECK_FILENAME_ONLY   検索時にファイル名のみを対
                                                象とします。("-p-")
                        M_USE_DRIVE_LETTER      格納ファイルのディレクトリー
                                                情報について，絶対パスを示
                                                すルートディレクトリーのセ
                                                パレータも利用します。
                                                ("-jf")
                        M_NOT_USE_DRIVE_LETTER  格納ファイルのルートディレ
                                                クトリ情報を無視します。
                        M_RECOVERY_ON           破損ヘッダを無視して，以降
                                                の格納ファイルにアクセスで
                                                きるようにします。("-jc")
                        M_ERROR_MESSAGE_ON      エラー時にメッセージを表示
                                                します。("-gm-")
                        M_ERROR_MESSAGE_OFF     エラー時にメッセージを表示
                                                しません。("-gm")

        _szOption       スイッチ。Unlha() と同じものが指定可能ですが，レス
                        ポンスファイルは使用できませんし，当然ながら指定で
                        きるのはスイッチだけです。

戻り値
        正常終了時      指定の書庫ファイルに対応したハンドルが返されます。
        エラー時        NULL を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

注意
        現バージョンでは，同時に複数のハンドルを利用する事はできません。
        Unlha() 等のルーチンを利用している関係上，グローバル変数を使いまくっ
        ているので…。

-----------------------------------------------------------------------
%r      int WINAPI UnlhaCloseArchive(
                       HARC  _harc
                   )
-----------------------------------------------------------------------
順序数  22
要求版  0.01
機能
        UnlhaOpenArchive() で割り付けたハンドルを解放します。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      0 を返します。
        エラー時        0 以外を返します。  エラーコードと意味については，
                        このドキュメントの項目 5 を参照してください。

-----------------------------------------------------------------------
%s      int WINAPI UnlhaFindFirst(
                       HARC              _harc,
                       LPCTSTR           _szWildName,
                       INDIVIDUALINFO *  _lpSubInfo
                   )
-----------------------------------------------------------------------
順序数   23 : UnlhaFindFirst
        323 : UnlhaFindFirstA
        623 : UnlhaFindFirstW
要求版  UnlhaFindFirst  : 0.01
        UnlhaFindFirstA : 2.39a
        UnlhaFindFirstW : 2.40
機能
        最初の格納ファイルの情報を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。
        _szWildName     検索するファイル名。ファイル名は複数指定が可能で，
                        書式は Unlha() でのファイルリスト部分と同じです。
        _lpSubInfo      結果を返すための INDIVIDUALINFO 型の構造体へのポイ
                        ンタ。API を使用する場合など結果を必要としない場合
                        は NULL を指定できます。

戻り値
        0               正常終了。_lpSubInfo  で指定された構造体に格納ファ
                        イルの情報を格納します。
        -1              検索終了。
        0，-1 以外      エラー終了。Unlha() 系と同じエラーコードを返します。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

注意
        エラーによってアプリ側で処理を続行するかどうか選べるようにすること
        から，エラー時に UnlhaCloseArchive() 相当の処理は行われません。従っ
        て，処理を中断する場合には，アプリ側で明示的に UnlhaCloseArchive()
        によりハンドルを開放する必要があります。

        Ver 0.97 より前の版では， UnlhaFindFirst() と次の UnlhaFindNext()
        では，API の処理の終了時に HARC で関連付けられている書庫を一旦閉じ
        る仕様になっています。 そのため，これらの API による検索でマッチす
        る度にファイルの開閉が行われることになり，環境によっては（特にファ
        イル処理関係にフックが掛かっている場合）処理が非常に重くなる可能性
        があります。特にウィルス検索ソフト等で書庫のチェックが行われるよう
        に設定されている場合は，まるで死んだようになることがあります。

        Ver 0.97 からはその都度の書庫の開閉は行わなくなっていますが， レジ
        ストリーの指定により従来の開閉を行わせることもできます。

-----------------------------------------------------------------------
%t      int WINAPI UnlhaFindNext(
                       HARC              _harc,
                       INDIVIDUALINFO *  _lpSubInfo
                   )
-----------------------------------------------------------------------
順序数   24 : UnlhaFindNext
        324 : UnlhaFindNextA
        624 : UnlhaFindNextW
要求版  UnlhaFindNext  : 0.01
        UnlhaFindNextA : 2.39a
        UnlhaFindNextW : 2.40
機能
        2 番目以降の格納ファイルの情報を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。
        _lpSubInfo      結果を返すための INDIVIDUALINFO 型の構造体へのポイ
                        ンタ。結果を必要としない場合は NULL を指定できます。

戻り値
        0               正常終了。_lpSubInfo  で指定された構造体に格納ファ
                        イルの情報を格納します。
        -1              検索終了。
        0，-1 以外      エラー終了。Unlha() 系と同じエラーコードを返します。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

注意
        エラーによってアプリ側で処理を続行するかどうか選べるようにすること
        から，エラー時に UnlhaCloseArchive() 相当の処理は行われません。従っ
        て，処理を中断する場合には，アプリ側で明示的に UnlhaCloseArchive()
        によりハンドルを開放する必要があります。

        Ver 0.97 より前の版では， 前の UnlhaFindFirst() と UnlhaFindNext()
        では，API の処理の終了時に HARC で関連付けられている書庫を一旦閉じ
        る仕様になっています。 そのため，これらの API による検索でマッチす
        る度にファイルの開閉が行われることになり，環境によっては（特にファ
        イル処理関係にフックが掛かっている場合）処理が非常に重くなる可能性
        があります。特にウィルス検索ソフト等で書庫のチェックが行われるよう
        に設定されている場合は，まるで死んだようになることがあります。

        Ver 0.97 からはその都度の書庫の開閉は行わなくなっていますが， レジ
        ストリーの指定により従来の開閉を行わせることもできます。

-----------------------------------------------------------------------
%u      int WINAPI UnlhaGetArcFileName(
                       HARC       _harc,
                       LPTSTR     _lpBuffer,
                       const int  _nSize
                   )
-----------------------------------------------------------------------
順序数   31 : UnlhaGetArcFileName
        331 : UnlhaGetArcFileNameA
        631 : UnlhaGetArcFileNameW
要求版  UnlhaGetArcFileName  : 0.01
        UnlhaGetArcFileNameA : 2.39a
        UnlhaGetArcFileNameW : 2.40
機能
        書庫ファイル名を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。
        _lpBuffer       ファイル名を格納するバッファ。
        _nSize          TCHAR 単位で示されたバッファのサイズ。

戻り値
        正常終了時      0 が返され，_lpBuffer に書庫ファイル名が格納されま
                        す。
        エラー時        0 以外を返します。  エラーコードと意味については，
                        このドキュメントの項目 5 を参照してください。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

-----------------------------------------------------------------------
%v      DWORD WINAPI UnlhaGetArcFileSize(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  32
要求版  0.01
機能
        書庫ファイルのサイズを得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      書庫ファイルのサイズを返します。
        4GB 以上の時    サイズの下位 32 ビットを返しますが， UnlhaGetLast-
                        Error() API で ERROR_TOO_BIG が返されます。
        エラー時        (DWORD)-1 を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        格納ファイルの合計サイズではなく，書庫そのもののサイズであることに
        注意してください。

        4GB を超えたサイズの書庫を扱った場合，サイズの下位 32 ビットが返り
        ます。エラーとはなりませんので注意してください。Ver 2.51a 以降であ
        れば，UnlhaGetLastError() が ERROR_TOO_BIG を返します。

-----------------------------------------------------------------------
%v      BOOL WINAPI UnlhaGetArcFileSizeEx(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllSize
                    )
-----------------------------------------------------------------------
順序数  103
要求版  1.56a
機能
        書庫ファイルのサイズを 64 ビット整数で得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。
        _lpllSize       情報を格納するためのバッファへのポインタ。 VC++ や
                        C++ Builder 5.x 等では実体は LONGLONG となっていま
                        す。BC++ 等 64ビット整数として LONGLONG を扱えない
                        コンパイラーを使用する場合には， (アラインメントの
                        ない) LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファに書庫のサイズが
                        格納されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        格納ファイルの合計サイズではなく，書庫そのもののサイズであることに
        注意してください。

-----------------------------------------------------------------------
%w      DWORD WINAPI UnlhaGetArcOriginalSize(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  33
要求版  0.01
機能
        検索にマッチしたファイルのサイズの合計を得ます。UnlhaFindNext() の
        検索が終了した後でないと返却値に意味はありません。検索中の場合はそ
        れまでにマッチしたファイルの合計となります。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      合計サイズを返します。
        4GB 以上の時    合計サイズの下位 32 ビットを返しますが， UnlhaGet-
                        LastError() API で ERROR_TOO_BIG が返されます。
        エラー時        (DWORD)-1 を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        UnlhaFindNext() の検索が終了してから呼び出すようにしてください。

        合計サイズが 4GB を超えている場合， サイズの下位 32 ビットが返りま
        す。エラーとはなりませんので注意してください。Ver 2.51a 以降であれ
        ば，UnlhaGetLastError() が ERROR_TOO_BIG を返します。

-----------------------------------------------------------------------
%w      BOOL WINAPI UnlhaGetArcOriginalSizeEx(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllSize
                    )
-----------------------------------------------------------------------
順序数  104
要求版  1.56a
機能
        検索にマッチしたファイルのサイズの合計を 64 ビット整数で得ます。
        UnlhaFindNext() の検索が終了した後でないと返却値に意味はありません。
        検索中の場合はそれまでにマッチしたファイルの合計となります。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。
        _lpllSize       情報を格納するためのバッファへのポインタ。 VC++ や
                        C++ Builder 5.x 等では実体は LONGLONG となっていま
                        す。BC++ 等 64ビット整数として LONGLONG を扱えない
                        コンパイラーを使用する場合には， (アラインメントの
                        ない) LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファにサイズの合計が
                        格納されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        UnlhaFindNext() の検索が終了してから呼び出すようにしてください。

-----------------------------------------------------------------------
%x      DWORD WINAPI UnlhaGetArcCompressedSize(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  34
要求版  0.01
機能
        検索にマッチしたファイルの圧縮サイズの合計を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      圧縮サイズの合計を返します。
        4GB 以上の時    圧縮サイズの下位 32 ビットを返しますが， UnlhaGet-
                        LastError() API で ERROR_TOO_BIG が返されます。
        エラー時        (DWORD)-1 を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        UnlhaFindNext() の検索が終了してから呼び出すようにしてください。

        圧縮サイズの合計が 4GB を超えている場合， サイズの下位 32 ビットが
        返ります。エラーとはなりませんので注意してください。Ver 2.51a 以降
        であれば，UnlhaGetLastError() が ERROR_TOO_BIG を返します。

-----------------------------------------------------------------------
%x      BOOL WINAPI UnlhaGetArcCompressedSizeEx(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllSize
                    )
-----------------------------------------------------------------------
順序数  105
要求版  1.56a
機能
        検索にマッチしたファイルの圧縮サイズの合計を 64 ビット整数で得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。
        _lpllSize       情報を格納するためのバッファへのポインタ。 VC++ や
                        C++ Builder 5.x 等では実体は LONGLONG となっていま
                        す。BC++ 等 64ビット整数として LONGLONG を扱えない
                        コンパイラーを使用する場合には， (アラインメントの
                        ない) LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファに圧縮サイズの合
                        計が格納されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        UnlhaFindNext() の検索が終了してから呼び出すようにしてください。

-----------------------------------------------------------------------
%y      WORD WINAPI UnlhaGetArcRatio(
                        HARC  _harc
                    )
-----------------------------------------------------------------------
順序数  35
要求版  0.01
機能
        検索にマッチしたファイルの全体の圧縮率を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      パーミル (千分率) で現された全体の圧縮率を返します。
        エラー時        (WORD)-1 を返します。 実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        UnlhaFindNext() の検索が終了してから呼び出すようにしてください。
        (圧縮サイズの合計 / ファイルの合計サイズ) * 1000  の計算により求め
        られることから，1000 を超える場合がある点に注意してください。

-----------------------------------------------------------------------
%z      WORD WINAPI UnlhaGetArcDate(
                        HARC  _harc
                    )
-----------------------------------------------------------------------
順序数  36
要求版  0.01
機能
        書庫ファイルの日付を MS-DOS 形式 (ローカルタイム) で得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      書庫ファイルの日付が返されます。形式は INDIVIDUAL-
                        INFO 構造体に格納されるものと同じで， 次のようなも
                        のです。

                            struct {
                                unsigned ft_day   : 5;  /* Days */
                                unsigned ft_month : 4;  /* Months */
                                unsigned ft_year  : 7;  /* Year */
                            } _DosDate;

                        つまり，ftime の上位ワードと同じ構造となっていて，
                        図示すると

                         15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
                        |<--- (年 - 1980) -->|<--- 月 -->|<---- 日 ---->|

                        のようになります。
        エラー時        (WORD)-1 を返します。 実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        ft_year に格納される値は 1980 年からの経過年数です。したがって，理
        論的には 2107 年いっぱいまで表現できることになります。

-----------------------------------------------------------------------
%A      WORD WINAPI UnlhaGetArcTime(
                        HARC  _harc
                    )
-----------------------------------------------------------------------
順序数  37
要求版  0.01
機能
        書庫ファイルの時刻を MS-DOS 形式 (ローカルタイム) で得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      書庫ファイルの時刻が返されます。形式は INDIVIDUAL-
                        INFO 構造体に格納されるものと同じで， 次のようなも
                        のです。

                            struct {
                                unsigned ft_tsec : 5;  /* Two second
                                                          interval */
                                unsigned ft_min  : 6;  /* Minutes */
                                unsigned ft_hour : 5;  /* Hours */
                            } _DosTime;

                        つまり，ftime の下位ワードと同じ構造となっていて，
                        図示すると

                          15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
                         |<---- 時 ---->|<------ 分 ----->|<- (秒 / 2) ->|

                        のようになります。
        エラー時        (WORD)-1 を返します。 実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        ft_tsec  に格納される値が秒を 2 で割ったものである点に注意してくだ
        さい。

<<重要>>
        NTFS 上のファイルや UNIX 等が起源のファイルの場合，00:00:01 等，秒
        の奇数である場合が当然ありますが，そのようなデータの扱いがプラット
        フォームにより異なっていることに注意してください。 Win32s，Windows
        95 では丸めの際に切り捨てが行われますが， その他では切り上げが行わ
        れます。 特に注意が必要なのは Windows 98 で， API のバグから，Set-
        FileTime()  等では切り上げが行われるにもかかわらず  FileTimeToDos-
        DateTime() では切り捨てられてしまいます。
        UNLHA32.DLL では， Win32 API を使用しないことにより，Windows 98 に
        おいても切り上げた数値が返されるようになっています。(Ver 1.32 以降)

-----------------------------------------------------------------------
%Q      DWORD WINAPI UnlhaGetArcCreateTime(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  125
要求版  2.60
機能
        書庫の作成日時 (UTC) を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      書庫の作成日時が UNIX 形式で返されます。 UNIX 形式
                        とは，Jan.1,1970 00:00:00 からの秒数です。
        エラー時        (DWORD)-1 を返します。  実際のエラーコードを得るに
                        は UnlhaGetLastError() API を使用してください。

注意
        LZH 書庫へ格納される情報に合わせて， UNIX 形式の情報を unsigned な
        値で返しています。そのため理論的には 2105 年まで表現できることにな
        りますが，現在の多くの処理系やアプリでは typedef long time_t; の定
        義によっているため， 2038 年以降を表すデータについて正常に扱われな
        い恐れがあります。

-----------------------------------------------------------------------
%Q      BOOL WINAPI UnlhaGetArcCreateTimeEx(
                        HARC        _harc,
                        FILETIME *  _lpftCreationTime
                    )
-----------------------------------------------------------------------
順序数  68
要求版  1.10
機能
        書庫の作成日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpftCreationTime       情報を格納する FILETIME 構造体へのポインタ。

戻り値
        正常終了時      TRUE が返され， 指定された FILETIME 構造体に作成日
                        時を格納します。FILETIME 形式とは Jan.1,1601 00:00:
                        00 からの 100ns 単位の経過時間を 64 ビットの数値で
                        表したものです。 詳しくは Win32 API のヘルプ等を参
                        照してください。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

-----------------------------------------------------------------------
%Q      BOOL WINAPI UnlhaGetArcCreateTime64(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllCreationTime
                    )
-----------------------------------------------------------------------
順序数  128
要求版  2.60
機能
        書庫の作成日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpllCreationTime       情報を格納するバッファへのポインタ。  VC++
                                や  C++ Builder 5.x 等では実体は  LONGLONG
                                となっています。BC++ 等 64ビット整数として
                                LONGLONG  を扱えないコンパイラーを使用する
                                場合には，(アラインメントのない)
                                LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファに作成日時を  64
                        ビットの UNIX 形式で格納します。UNIX 形式とは，
                        Jan.1,1970 00:00:00 からの秒数です。それより前の作
                        成日時については負数で表現されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

-----------------------------------------------------------------------
%R      DWORD WINAPI UnlhaGetArcAccessTime(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  126
要求版  2.60
機能
        書庫の参照日時 (UTC) を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      書庫の参照日時が UNIX 形式で返されます。 UNIX 形式
                        とは，Jan.1,1970 00:00:00 からの秒数です。
        エラー時        (DWORD)-1 を返します。  実際のエラーコードを得るに
                        は UnlhaGetLastError() API を使用してください。

注意
        LZH 書庫へ格納される情報に合わせて， UNIX 形式の情報を unsigned な
        値で返しています。そのため理論的には 2105 年まで表現できることにな
        りますが，現在の多くの処理系やアプリでは typedef long time_t; の定
        義によっているため， 2038 年以降を表すデータについて正常に扱われな
        い恐れがあります。

-----------------------------------------------------------------------
%R      BOOL WINAPI UnlhaGetArcAccessTimeEx(
                        HARC        _harc,
                        FILETIME *  _lpftLastAccessTime
                    )
-----------------------------------------------------------------------
順序数  69
要求版  1.10
機能
        書庫の参照日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpftLastAccessTime     情報を格納する FILETIME 構造体へのポインタ。

戻り値
        正常終了時      TRUE が返され， 指定された FILETIME 構造体に参照日
                        時を格納します。FILETIME 形式とは Jan.1,1601 00:00:
                        00 からの 100ns 単位の経過時間を 64 ビットの数値で
                        表したものです。 詳しくは Win32 API のヘルプ等を参
                        照してください。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

-----------------------------------------------------------------------
%R      BOOL WINAPI UnlhaGetArcAccessTime64(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllLastAccessTime
                    )
-----------------------------------------------------------------------
順序数  129
要求版  2.60
機能
        書庫の参照日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpllLastAccessTime     情報を格納するバッファへのポインタ。  VC++
                                や  C++ Builder 5.x 等では実体は  LONGLONG
                                となっています。BC++ 等 64ビット整数として
                                LONGLONG  を扱えないコンパイラーを使用する
                                場合には，(アラインメントのない)
                                LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファに参照日時を  64
                        ビットの UNIX 形式で格納します。UNIX 形式とは，
                        Jan.1,1970 00:00:00 からの秒数です。それより前の参
                        照日時については負数で表現されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

-----------------------------------------------------------------------
%S      DWORD WINAPI UnlhaGetArcWriteTime(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  124
要求版  2.60
機能
        書庫の最終更新日時 (UTC) を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      書庫の更新日時が UNIX 形式で返されます。 UNIX 形式
                        とは，Jan.1,1970 00:00:00 からの秒数です。
        エラー時        (DWORD)-1 を返します。  実際のエラーコードを得るに
                        は UnlhaGetLastError() API を使用してください。

注意
        LZH 書庫へ格納される情報に合わせて， UNIX 形式の情報を unsigned な
        値で返しています。そのため理論的には 2105 年まで表現できることにな
        りますが，現在の多くの処理系やアプリでは typedef long time_t; の定
        義によっているため， 2038 年以降を表すデータについて正常に扱われな
        い恐れがあります。

-----------------------------------------------------------------------
%S      BOOL WINAPI UnlhaGetArcWriteTimeEx(
                        HARC        _harc,
                        FILETIME *  _lpftLastWriteTime
                    )
-----------------------------------------------------------------------
順序数  70
要求版  1.10
機能
        書庫の最終更新日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpftLastWriteTime      情報を格納する FILETIME 構造体へのポインタ。

戻り値
        正常終了時      TRUE が返され， 指定された FILETIME 構造体に更新日
                        時を格納します。FILETIME 形式とは Jan.1,1601 00:00:
                        00 からの 100ns 単位の経過時間を 64 ビットの数値で
                        表したものです。 詳しくは Win32 API のヘルプ等を参
                        照してください。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

-----------------------------------------------------------------------
%S      BOOL WINAPI UnlhaGetArcWriteTime64(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllLastWriteTime
                    )
-----------------------------------------------------------------------
順序数  127
要求版  2.60
機能
        書庫の最終更新日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpllLastWriteTime      情報を格納するバッファへのポインタ。  VC++
                                や  C++ Builder 5.x 等では実体は  LONGLONG
                                となっています。BC++ 等 64ビット整数として
                                LONGLONG  を扱えないコンパイラーを使用する
                                場合には，(アラインメントのない)
                                LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファに更新日時を  64
                        ビットの UNIX 形式で格納します。UNIX 形式とは，
                        Jan.1,1970 00:00:00 からの秒数です。それより前の更
                        新日時については負数で表現されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

-----------------------------------------------------------------------
%B      UINT WINAPI UnlhaGetArcOSType(
                        HARC  _harc
                    )
-----------------------------------------------------------------------
順序数  38
要求版  0.01
機能
        書庫ファイル作成に使用された OS の種類を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      OS の種類を表す以下の数値が返されます。

                                 0      MS-DOS
                                 2      UNIX
                                 4      旧 MAC-OS
                                 5      OS/2
                                10      その他
                                11      OS9 (MAC の新型ではない ^^;)
                                12      OS/68K
                                13      OS/386
                                14      HUMAN
                                15      CP/M
                                16      FLEX
                                17      Runser
                                18      Windows NT 系 OS
                                19      Windows 95 系 OS

        エラー時        (UINT)-1 を返します。 実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        18 (NT)，19 (Win 95) が返ってくる書庫はほとんどない (というか皆無)
        はずです。普通は 0 (DOS) が返ってきます。

-----------------------------------------------------------------------
%C      int WINAPI UnlhaIsSFXFile(
                       HARC  _harc
                   )
-----------------------------------------------------------------------
順序数  39
要求版  0.80
機能
        書庫ファイルが自己解凍書庫かどうかを得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      書庫ファイルの種類をあらわす次の数値を返します。
                        ここでの区分は，扱える圧縮形式など書庫に関するもの
                        となっている点に注意してください。$ コマンド等の違
                        いについては，この API の返却値では区別できません。

                SFX_NOT              0  自己解凍書庫(SFX)ではない
                SFX_DOS_204S         1  LHA's SFX 2.04 以降の small DosSFX
                SFX_DOS_250S         2  LHA's SFX 2.50 以降の small DosSFX
                SFX_DOS_265S         3  LHA's SFX 2.65 以降の small DosSFX
                SFX_DOS_204L        51  LHA's SFX 2.04 以降の large DosSFX
                SFX_DOS_250L        52  LHA's SFX 2.50 以降の large DosSFX
                SFX_DOS_265L        53  LHA's SFX 2.65 以降の large DosSFX
                SFX_DOS_LARC       201  SFX by LARC
                SFX_DOS_LHARC_S    202  LHarc's SFX（small）
                SFX_DOS_LHARC_L    252  LHarc's SFX（large）
                SFX_WIN16_213_1   1001  LHA's SFX 2.13.w16.1 以降の WinSFX
                SFX_WIN16_213_2   1002  LHA's SFX 2.13.w16.2 以降の WinSFX
                SFX_WIN16_213_3   1003  改良版 LHA's SFX 2.13.w16.3 WinSFX
                SFX_WIN16_250_1   1011  UNLHA32.DLL  独自の改良版  WinSFXM
                                        2.50
                SFX_WIN16_255_1   1021  WinSFXM 2.55.w16.4 以降
                SFX_WIN32_213_1   2001  LHA's SFX 2.13.w32.1 以降の
                                        WinSFX32
                SFX_WIN32_213_3   2002  改良版 LHA's SFX 2.13.w32.3
                                        WinSFX32
                SFX_WIN32_250_1   2011  UNLHA32.DLL 独自の改良版 WinSFX32M
                SFX_WIN32_250_6   2012  WinSFX32M 2.50.w32.6 以降
                SFX_WIN32_300_1   2021  UNLHA32.DLL 独自の Unicode 対応版
                                        WinSFX32M (WinSFX32U)
                SFX_LZHSFX_1002   2051  Explorer  拡張メニューで作成される
                                        LZHSFX 1.0.0.2 以降の WinSFX32
                SFX_LZHSFX_1100   2052  Explorer  拡張メニューで作成される
                                        LZHSFX 1.1.0.0 以降の WinSFX32
                SFX_LZHAUTO_0002  2101  Explorer  拡張メニューで作成される
                                        LZHAUTO 0.0.0.2 以降の WinSFX32
                SFX_LZHAUTO_1000  2102  Explorer  拡張メニューで作成される
                                        LZHAUTO 1.0.0.0 以降の WinSFX32
                SFX_LZHAUTO_1100  2103  Explorer  拡張メニューで作成される
                                        LZHAUTO 1.1.0.0 以降の WinSFX32
                SFX_WIN32_LHASA   3001  Lhasa インストーラ
                SFX_DOS_UNKNOWN   9901  認識できない DOS SFX
                SFX_WIN16_UNKNOWN 9911  認識できない Win16 SFX
                SFX_WIN32_UNKNOWN 9921  認識できない Win32 SFX

        エラー時        (UINT)-1 を返します。 実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        自己解凍書庫については，書庫自体に自己解凍書庫であることを示すフラ
        グやバージョン等の情報が存在するわけではありませんので，自己解凍書
        庫のバージョンによっては正しく認識できない場合があります。  特に，
        COM 形式の SFX  では通常の書庫と認識されてしまう可能性があります。
        (なんで Windows 95 で GetBinaryType() が使えないのじゃ。 ^^;)
        UNLHA32.DLL は，基本的に上記の LHA，ファイルマネージャ拡張メニュー，
        Explorer 拡張メニュー，それと UNLHA32.DLL 自身が作成するもの以外の
        自己解凍書庫は認識できません。

-----------------------------------------------------------------------
%T      DWORD WINAPI UnlhaGetArcReadSize(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  113
要求版  1.80
機能
        UnlhaFindFirst/Next() で今までに書庫を読み込んだサイズを得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      合計サイズを返します。
        4GB 以上の時    合計サイズの下位 32 ビットを返しますが， UnlhaGet-
                        LastError() API で ERROR_TOO_BIG が返されます。
        エラー時        (DWORD)-1 を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        4GB を超えたサイズの書庫を扱った場合，読み込んだサイズの下位 32
        ビットが返ります。 エラーとはなりませんので注意してください。  Ver
        2.51a 以降であれば， UnlhaGetLastError() が ERROR_TOO_BIG を返しま
        す。

-----------------------------------------------------------------------
%T      BOOL WINAPI UnlhaGetArcReadSizeEx(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllSize
                    )
-----------------------------------------------------------------------
順序数  114
要求版  1.80
機能
        UnlhaFindFirst/Next() で今までに書庫を読み込んだサイズを得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。
        _lpllSize       情報を格納するためのバッファへのポインタ。 VC++ や
                        C++ Builder 5.x 等では実体は LONGLONG となっていま
                        す。BC++ 等 64ビット整数として LONGLONG を扱えない
                        コンパイラーを使用する場合には， (アラインメントの
                        ない) LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファに合計サイズが格
                        納されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

-----------------------------------------------------------------------
%D      int WINAPI UnlhaGetFileName(
                       HARC       _harc,
                       LPTSTR     _lpBuffer,
                       const int  _nSize
                   )
-----------------------------------------------------------------------
順序数   40 : UnlhaGetFileName
        340 : UnlhaGetFileNameA
        640 : UnlhaGetFileNameW
要求版  UnlhaGetFileName  : 0.01
        UnlhaGetFileNameA : 2.39a
        UnlhaGetFileNameW : 2.40
機能
        格納ファイルのファイル名を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。
        _lpBuffer       ファイル名を格納するバッファ。
        _nSize          TCHAR 単位で示されたバッファのサイズ。

戻り値
        正常終了時      0 が返され，_lpBuffer にファイル名が格納されます。
        エラー時        0 以外を返します。  エラーコードと意味については，
                        このドキュメントの項目 5 を参照してください。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

注意
        Ver 2.39 以降においては， ANSI 版 API では，当該メンバーが Unicode
        ファイル名ヘッダや Unicode パス名ヘッダ  (それぞれ， 拡張ヘッダ ID
        0x44，0x45) をもっていた場合，Unicode から ANSI へ変換を行った結果
        が返されます。 そのため， 当該書庫の作成時と異なる環境においては，
        ファイル名ヘッダやパス名ヘッダ (それぞれ，拡張ヘッダ ID 0x01，0x02)
        に記録されている名前と異なる場合があります。
        例えば，日本語環境 (コードページ 932) で "TEST(c).TXT" ((c) は Uni-
        code の U+00A9) といった名前のファイルを格納した場合，ファイル名ヘッ
        ダには "TEST_.TXT" が記録されますが，当該書庫を英語環境 (コードペー
        ジ 1252) で扱った場合，UnlhaGetFileName() は "TEST(c).TXT" ((c) は
        ANSI コードページ 1252 の 0xA9) を返します。
        Unicode ファイル名ヘッダ等が存在しない場合でも，コードページヘッダ
        が記録されている場合には， 同様の現象が発生します。 例えば，上記の
        ファイルを英語環境で格納した場合， ファイル名ヘッダには  "TEST(c).
        TXT" ((c) は ANSI コードページ 1252 の 0xA9) が記録されます  (英語
        環境なので Unicode ファイル名ヘッダを必要としない) が， 当該書庫を
        日本語環境で扱った場合，UnlhaGetFileName() は "TEST_.TXT" を返しま
        す。

-----------------------------------------------------------------------
%E      int WINAPI UnlhaGetMethod(
                       HARC       _harc,
                       LPTSTR     _lpBuffer,
                       const int  _nSize
                   )
-----------------------------------------------------------------------
順序数   61 : UnlhaGetMethod
        361 : UnlhaGetMethodA
        661 : UnlhaGetMethodW
要求版  UnlhaGetMethod  : 0.01
        UnlhaGetMethodA : 2.39a
        UnlhaGetMethodW : 2.40
機能
        格納ファイルの圧縮法を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。
        _lpBuffer       メソッド名を格納するバッファ。
        _nSize          TCHAR 単位で示されたバッファのサイズ。

戻り値
        正常終了時      0 が返され，_lpBuffer に圧縮法を示す文字列が格納さ
                        れます。 文字列は一覧リスト等で表示される "lh5" と
                        いった形式のものとなります。メソッドの種類について
                        は COMMAND.TXT を参照してください。
        エラー時        0 以外を返します。  エラーコードと意味については，
                        このドキュメントの項目 5 を参照してください。

Unicode
        Ver 2.40 以降では Unicode 版と ANSI 版が実装されていますが，Win 9x
        系については， システムが Unicode に対応していないことから，最終的
        には ANSI へ変換されて処理が行われます。

-----------------------------------------------------------------------
%F      DWORD WINAPI UnlhaGetOriginalSize(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  41
要求版  0.01
機能
        格納ファイルのサイズを得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      格納ファイルのサイズを返します。
        4GB 以上の時    サイズの下位 32 ビットを返しますが， UnlhaGetLast-
                        Error() API で ERROR_TOO_BIG が返されます。
        エラー時        (DWORD)-1 を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        4GB を超えたサイズのメンバーを扱った場合，サイズの下位 32 ビットが
        返ります。エラーとはなりませんので注意してください。Ver 2.51a 以降
        であれば，UnlhaGetLastError() が ERROR_TOO_BIG を返します。

-----------------------------------------------------------------------
%F      BOOL WINAPI UnlhaGetOriginalSizeEx(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllSize
                    )
-----------------------------------------------------------------------
順序数  106
要求版  1.56a
機能
        格納ファイルのサイズを 64 ビット整数で得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。
        _lpllSize       情報を格納するためのバッファへのポインタ。 VC++ や
                        C++ Builder 5.x 等では実体は LONGLONG となっていま
                        す。BC++ 等 64ビット整数として LONGLONG を扱えない
                        コンパイラーを使用する場合には， (アラインメントの
                        ない) LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファに格納ファイルの
                        サイズが格納されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

-----------------------------------------------------------------------
%G      DWORD WINAPI UnlhaGetCompressedSize(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  42
要求版  0.01
機能
        格納ファイルの圧縮サイズを得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      格納ファイルの圧縮サイズを返します。
        4GB 以上の時    圧縮サイズの下位 32 ビットを返しますが， UnlhaGet-
                        LastError() API で ERROR_TOO_BIG が返されます。
        エラー時        (DWORD)-1 を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        圧縮後のサイズが 4GB を超えたメンバーを扱った場合， 圧縮サイズの下
        位 32 ビットが返ります。エラーとはなりませんので注意してください。
        Ver 2.51a 以降であれば， UnlhaGetLastError() が ERROR_TOO_BIG を返
        します。

-----------------------------------------------------------------------
%G      BOOL WINAPI UnlhaGetCompressedSizeEx(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllSize
                    )
-----------------------------------------------------------------------
順序数  107
要求版  1.56a
機能
        格納ファイルの圧縮サイズを 64 ビット整数で得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。
        _lpllSize       情報を格納するためのバッファへのポインタ。 VC++ や
                        C++ Builder 5.x 等では実体は LONGLONG となっていま
                        す。BC++ 等 64ビット整数として LONGLONG を扱えない
                        コンパイラーを使用する場合には， (アラインメントの
                        ない) LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファに格納ファイルの
                        圧縮サイズが格納されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

-----------------------------------------------------------------------
%H      WORD WINAPI UnlhaGetRatio(
                        HARC  _harc
                    )
-----------------------------------------------------------------------
順序数  43
要求版  0.01
機能
        格納ファイルの圧縮率を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      パーミル (千分率) で現された格納ファイルの圧縮率を
                        返します。
        エラー時        (WORD)-1 を返します。 実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        (圧縮サイズ / ファイルのサイズ) * 1000  の計算により求められること
        から，1000 を超える場合がある点に注意してください。

-----------------------------------------------------------------------
%I      WORD WINAPI UnlhaGetDate(
                        HARC  _harc
                    )
-----------------------------------------------------------------------
順序数  44
要求版  0.01
機能
        格納ファイルの日付を MS-DOS 形式 (ローカルタイム) で得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      格納ファイルの日付が返されます。形式は INDIVIDUAL-
                        INFO 構造体に格納されるものと同じで， 次のようなも
                        のです。

                            struct {
                                unsigned ft_day   : 5;  /* Days */
                                unsigned ft_month : 4;  /* Months */
                                unsigned ft_year  : 7;  /* Year */
                            } _DosDate;

                        つまり，ftime の上位ワードと同じ構造となっていて，
                        図示すると

                         15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
                        |<--- (年 - 1980) -->|<--- 月 -->|<---- 日 ---->|

                        のようになります。
        エラー時        (WORD)-1 を返します。 実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        ft_year に格納される値は 1980 年からの経過年数です。したがって，理
        論的には 2107 年いっぱいまで表現できることになります。

-----------------------------------------------------------------------
%J      WORD WINAPI UnlhaGetTime(
                        HARC  _harc
                    )
-----------------------------------------------------------------------
順序数  45
要求版  0.01
機能
        格納ファイルの時刻を MS-DOS 形式 (ローカルタイム) で得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      格納ファイルの時刻が返されます。形式は INDIVIDUAL-
                        INFO 構造体に格納されるものと同じで， 次のようなも
                        のです。

                            struct {
                                unsigned ft_tsec : 5;  /* Two second
                                                          interval */
                                unsigned ft_min  : 6;  /* Minutes */
                                unsigned ft_hour : 5;  /* Hours */
                            } _DosTime;

                        つまり，ftime の下位ワードと同じ構造となっていて，
                        図示すると

                          15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
                         |<---- 時 ---->|<------ 分 ----->|<- (秒 / 2) ->|

                        のようになります。
        エラー時        (WORD)-1 を返します。 実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        ft_tsec  に格納される値が秒を 2 で割ったものである点に注意してくだ
        さい。

<<重要>>
        NTFS 上のファイルや UNIX 等が起源のファイルの場合，00:00:01 等，秒
        の奇数である場合が当然ありますが，そのようなデータの扱いがプラット
        フォームにより異なっていることに注意してください。 Win32s，Windows
        95 では丸めの際に切り捨てが行われますが， その他では切り上げが行わ
        れます。 特に注意が必要なのは Windows 98 で， API のバグから，Set-
        FileTime()  等では切り上げが行われるにもかかわらず  FileTimeToDos-
        DateTime() では切り捨てられてしまいます。
        UNLHA32.DLL では， Win32 API を使用しないことにより，Windows 98 に
        おいても切り上げた数値が返されるようになっています。(Ver 1.32 以降)

-----------------------------------------------------------------------
%K      DWORD WINAPI UnlhaGetWriteTime(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  62
要求版  0.39
機能
        格納ファイルの最終更新日時 (UTC) を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      格納ファイルの更新日時が UNIX 形式で返されます。
                        UNIX 形式とは，Jan.1,1970 00:00:00 からの秒数です。
        エラー時        (DWORD)-1 を返します。  実際のエラーコードを得るに
                        は UnlhaGetLastError() API を使用してください。

注意
        h0/h1 形式ヘッダでは， UnlhaGetTime() で得られる MS-DOS 形式の情報
        を UNIX 形式に変換したものとなります。 h2 形式では書庫に格納されて
        いる情報がそのまま返されます。
        LZH 書庫に格納される UNIX 形式の情報については， unsigned なもので
        あるため理論的には 2105 年まで表現できることになりますが，現在の多
        くの処理系やアプリでは typedef long time_t; の定義によっているため，
        2038 年以降を表すデータについて正常に扱われない恐れがあります。

-----------------------------------------------------------------------
%K      BOOL WINAPI UnlhaGetWriteTimeEx(
                        HARC        _harc,
                        FILETIME *  _lpftLastWriteTime
                    )
-----------------------------------------------------------------------
順序数  65
要求版  1.00
機能
        格納ファイルの最終更新日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpftLastWriteTime      情報を格納する FILETIME 構造体へのポインタ。

戻り値
        正常終了時      TRUE が返され， 指定された FILETIME 構造体に更新日
                        時を格納します。FILETIME 形式とは Jan.1,1601 00:00:
                        00 からの 100ns 単位の経過時間を 64 ビットの数値で
                        表したものです。 詳しくは Win32 API のヘルプ等を参
                        照してください。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        この API で得られる情報は， UNLHA32.DLL を使用して作成された h2 形
        式書庫に固有の拡張ヘッダによるものです。従って，その情報をもたない
        h0/h1 形式や他のツールで作成された h2 形式書庫については，書庫から
        得られる情報 (MS-DOS 及び UNIX 形式) を  FILETIME 構造体に変換した
        ものとなります。

-----------------------------------------------------------------------
%K      BOOL WINAPI UnlhaGetWriteTime64(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllLastWriteTime
                    )
-----------------------------------------------------------------------
順序数  130
要求版  2.60
機能
        格納ファイルの最終更新日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpllLastWriteTime      情報を格納するバッファへのポインタ。  VC++
                                や  C++ Builder 5.x 等では実体は  LONGLONG
                                となっています。BC++ 等 64ビット整数として
                                LONGLONG  を扱えないコンパイラーを使用する
                                場合には，(アラインメントのない)
                                LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファに更新日時を  64
                        ビットの UNIX 形式で格納します。UNIX 形式とは，
                        Jan.1,1970 00:00:00 からの秒数です。それより前の更
                        新日時については負数で表現されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        この API で得られる情報は， UNLHA32.DLL を使用して作成された h2 形
        式書庫に固有の拡張ヘッダによるものです。従って，その情報をもたない
        h0/h1 形式や他のツールで作成された h2 形式書庫については，書庫から
        得られる情報 (MS-DOS 及び UNIX 形式) を変換したものとなります。

-----------------------------------------------------------------------
%L      DWORD WINAPI UnlhaGetCreateTime(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  63
要求版  0.39
機能
        格納ファイルの作成日時 (UTC) を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      格納ファイルの作成日時が UNIX 形式で返されます。
                        UNIX 形式とは，Jan.1,1970 00:00:00 からの秒数です。
        エラー時        (DWORD)-1 を返します。  実際のエラーコードを得るに
                        は UnlhaGetLastError() API を使用してください。

注意
        Ver 1.30b より前の版では，UnlhaGetWriteTime() と同じ値が返されます。
        Ver 1.30b 以降の版では，UnlhaGetCreateTimeEx() で得られる FILETIME
        構造体の情報を UNIX 形式に変換したものとなります。
        LZH 書庫に格納される UNIX 形式の情報については， unsigned なもので
        あるため理論的には 2105 年まで表現できることになりますが，現在の多
        くの処理系やアプリでは typedef long time_t; の定義によっているため，
        2038 年以降を表すデータについて正常に扱われない恐れがあります。

-----------------------------------------------------------------------
%L      BOOL WINAPI UnlhaGetCreateTimeEx(
                        HARC        _harc,
                        FILETIME *  _lpftCreationTime
                    )
-----------------------------------------------------------------------
順序数  66
要求版  1.00
機能
        格納ファイルの作成日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpftCreationTime       情報を格納する FILETIME 構造体へのポインタ。

戻り値
        正常終了時      TRUE が返され， 指定された FILETIME 構造体に作成日
                        時を格納します。FILETIME 形式とは Jan.1,1601 00:00:
                        00 からの 100ns 単位の経過時間を 64 ビットの数値で
                        表したものです。 詳しくは Win32 API のヘルプ等を参
                        照してください。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        この API で得られる情報は， UNLHA32.DLL を使用して作成された h2 形
        式書庫に固有の拡張ヘッダによるものです。従って，その情報をもたない
        h0/h1 形式や他のツールで作成された h2 形式書庫については，書庫から
        得られる情報 (MS-DOS 及び UNIX 形式による更新日時)  を FILETIME 構
        造体に変換したものとなります。

-----------------------------------------------------------------------
%L      BOOL WINAPI UnlhaGetCreateTime64(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllCreationTime
                    )
-----------------------------------------------------------------------
順序数  131
要求版  2.60
機能
        格納ファイルの作成日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpllCreationTime       情報を格納するバッファへのポインタ。  VC++
                                や  C++ Builder 5.x 等では実体は  LONGLONG
                                となっています。BC++ 等 64ビット整数として
                                LONGLONG  を扱えないコンパイラーを使用する
                                場合には，(アラインメントのない)
                                LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファに作成日時を  64
                        ビットの UNIX 形式で格納します。UNIX 形式とは，
                        Jan.1,1970 00:00:00 からの秒数です。それより前の作
                        成日時については負数で表現されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        この API で得られる情報は， UNLHA32.DLL を使用して作成された h2 形
        式書庫に固有の拡張ヘッダによるものです。従って，その情報をもたない
        h0/h1 形式や他のツールで作成された h2 形式書庫については，書庫から
        得られる情報 (MS-DOS 及び UNIX 形式) を変換したものとなります。

-----------------------------------------------------------------------
%M      DWORD WINAPI UnlhaGetAccessTime(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  64
要求版  0.39
機能
        格納ファイルの参照日時 (UTC) を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      格納ファイルの参照日時が UNIX 形式で返されます。
                        UNIX 形式とは，Jan.1,1970 00:00:00 からの秒数です。
        エラー時        (DWORD)-1 を返します。  実際のエラーコードを得るに
                        は UnlhaGetLastError() API を使用してください。

注意
        Ver 1.30b より前の版では，UnlhaGetWriteTime() と同じ値が返されます。
        Ver 1.30b 以降の版では，UnlhaGetAccessTimeEx() で得られる FILETIME
        構造体の情報を UNIX 形式に変換したものとなります。
        LZH 書庫に格納される UNIX 形式の情報については， unsigned なもので
        あるため理論的には 2105 年まで表現できることになりますが，現在の多
        くの処理系やアプリでは typedef long time_t; の定義によっているため，
        2038 年以降を表すデータについて正常に扱われない恐れがあります。

-----------------------------------------------------------------------
%M      BOOL WINAPI UnlhaGetAccessTimeEx(
                        HARC        _harc,
                        FILETIME *  _lpftLastAccessTime
                    )
-----------------------------------------------------------------------
順序数  67
要求版  1.00
機能
        格納ファイルの参照日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpftLastAccessTime     情報を格納する FILETIME 構造体へのポインタ。

戻り値
        正常終了時      TRUE が返され， 指定された FILETIME 構造体に参照日
                        時を格納します。FILETIME 形式とは Jan.1,1601 00:00:
                        00 からの 100ns 単位の経過時間を 64 ビットの数値で
                        表したものです。 詳しくは Win32 API のヘルプ等を参
                        照してください。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        この API で得られる情報は， UNLHA32.DLL を使用して作成された h2 形
        式書庫に固有の拡張ヘッダによるものです。従って，その情報をもたない
        h0/h1 形式や他のツールで作成された h2 形式書庫については，書庫から
        得られる情報 (MS-DOS 及び UNIX 形式による更新日時)  を FILETIME 構
        造体に変換したものとなります。

-----------------------------------------------------------------------
%M      BOOL WINAPI UnlhaGetAccessTime64(
                        HARC          _harc,
                        ULHA_INT64 *  _lpllLastAccessTime
                    )
-----------------------------------------------------------------------
順序数  132
要求版  2.60
機能
        格納ファイルの参照日時 (UTC) を得ます。

引数
        _harc                   UnlhaOpenArchive() で返されたハンドル。
        _lpftLastAccessTime     情報を格納するバッファへのポインタ。  VC++
                                や  C++ Builder 5.x 等では実体は  LONGLONG
                                となっています。BC++ 等 64ビット整数として
                                LONGLONG  を扱えないコンパイラーを使用する
                                場合には，(アラインメントのない)
                                LARGE_INTEGER 等で代用してください。

戻り値
        正常終了時      TRUE が返され， 指定されたバッファに参照日時を  64
                        ビットの UNIX 形式で格納します。UNIX 形式とは，
                        Jan.1,1970 00:00:00 からの秒数です。それより前の参
                        照日時については負数で表現されます。
        エラー時        FALSE を返します。実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。

注意
        この API で得られる情報は， UNLHA32.DLL を使用して作成された h2 形
        式書庫に固有の拡張ヘッダによるものです。従って，その情報をもたない
        h0/h1 形式や他のツールで作成された h2 形式書庫については，書庫から
        得られる情報 (MS-DOS 及び UNIX 形式) を変換したものとなります。

-----------------------------------------------------------------------
%N      DWORD WINAPI UnlhaGetCRC(
                         HARC  _harc
                     )
-----------------------------------------------------------------------
順序数  46
要求版  0.01
機能
        格納ファイルのチェックサムを得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      格納ファイルのチェックサムが返されます。
        エラー時        (DWORD)-1 が返されます。

-----------------------------------------------------------------------
%O      int WINAPI UnlhaGetAttribute(
                       HARC  _harc
                   )
-----------------------------------------------------------------------
順序数  47
要求版  0.01
機能
        格納ファイルの属性を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      格納ファイルの属性が返されます。以下のフラグを組み
                        合わせたものとなります。

                         1      FA_RDONLY       読み込み専用ファイル。
                         2      FA_HIDDEN       不可視属性ファイル。
                         4      FA_SYSTEM       システムファイル。
                         8      FA_LABEL        ボリュームラベル。
                        16      FA_DIREC        ディレクトリー。
                        32      FA_ARCH         保存ビット。

        エラー時        -1 が返されます。

注意
        LHA for UNIX 等，MS-DOS/Windows 系以外の OS を想定したツールで作成
        される書庫では， 属性等の扱いが異なるために h1/h2 形式書庫において
        は UNLHA32.DLL を含めた MS-DOS/Windows 系ツール (オリジナルも同じ)
        が想定している項目に情報を書き込みません。
        従って，それらのツールで作成された書庫については，正しい属性値が得
        られないことになりますので，注意してください。
        UNLHA32.DLL については， Ver 1.88a 以降で，LHA for UNIX で作成され
        た書庫について，一部の属性情報 (読込専用とディレクトリー) を解釈設
        定するようになっています。

参考
        実際には，拡張ヘッダの属性項目がそのまま使用されることから，UNLHA-
        32.DLL で作成された書庫については， GetFileAttributes() API で得ら
        れた結果の下位ワードと同等のものになります。それらの内，下位バイト
        だけが展開時の属性として扱われます：

                FILE_ATTRIBUTE_READONLY         0x00000001
                FILE_ATTRIBUTE_HIDDEN           0x00000002
                FILE_ATTRIBUTE_SYSTEM           0x00000004
                FILE_ATTRIBUTE_DIRECTORY        0x00000010
                FILE_ATTRIBUTE_ARCHIVE          0x00000020

-----------------------------------------------------------------------
%O      int WINAPI UnlhaGetAttributes(
                       HARC  _harc
                   )
-----------------------------------------------------------------------
順序数  120
要求版  2.02a
機能
        格納ファイルの属性を得ます。UnlhaGetAttribute() がスペルミスであっ
        たため， 本来の名前のものを用意しただけで，  内部的には  UnlhaGet-
        Attribute() を，そのまま呼び出しています。


引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        UnlhaGetAttribute() の項を参照。

注意
        UnlhaGetAttribute() の項を参照。

参考
        UnlhaGetAttribute() の項を参照。

-----------------------------------------------------------------------
%P      UINT WINAPI UnlhaGetOSType(
                        HARC _harc
                    )
-----------------------------------------------------------------------
順序数  48
要求版  0.01
機能
        格納ファイルが作成された OS を得ます。

引数
        _harc           UnlhaOpenArchive() で返されたハンドル。

戻り値
        正常終了時      OS の種類を表す以下の数値が返されます。

                                 0      MS-DOS
                                 2      UNIX
                                 4      旧 MAC-OS
                                 5      OS/2
                                10      その他
                                11      OS9 (MAC の新型ではない ^^;)
                                12      OS/68K
                                13      OS/386
                                14      HUMAN
                                15      CP/M
                                16      FLEX
                                17      Runser
                                18      Windows NT 系 OS
                                19      Windows 95 系 OS

        エラー時        (UINT)-1 を返します。 実際のエラーコードを得るには
                        UnlhaGetLastError() API を使用してください。


--------------------------------------------------------------------------
その他の API
--------------------------------------------------------------------------

　Unlha() 系 や OpenArchive 系，その他のドキュメントで説明されているカテゴ
リに属さない API 群です。

-----------------------------------------------------------------------
%U      BOOL WINAPI UnlhaSetUnicodeMode(
                        const BOOL  _bUnicode
                    )
-----------------------------------------------------------------------
順序数  133
要求版  2.62
機能
        ANSI 版 API を UTF-8 の文字コードで使用するかどうかを指定します。
        既定は ANSI (CP_THREAD_ACP 又は CP_ACP) です。

引数
        UTF-8 (CP_UTF8) で使用する場合は TRUE を渡します。
        ANSI (CP_THREAD_ACP 又は CP_ACP) で使用する場合は FALSE を渡します。

戻り値
        正常終了        TRUE を返します。
        異常終了        動作中で変更できなかった場合や，引数が間違いの場合
                        には FALSE を返します。 実際のエラーコードを得るに
                        は UnlhaGetLastError() API を使用してください。

注意
        この API  で指定されたコードがレスポンスファイルやログにも適用され
        る点に注意が必要です。 UTF-8 を指定した場合，ANSI コードで記述され
        たレスポンスファイルを使用することは出来ません (BOM 無しのファイル
        は UTF-8 で扱われます)。

-----------------------------------------------------------------------
%V      BOOL WINAPI UnlhaSetPriority(
                        const int  _nPriority
                    )
-----------------------------------------------------------------------
順序数  119
要求版  1.92
機能
        UNLHA32.DLL の優先順位 (プライオリティ) を指定します。

引数
        _nPriority      優先順位。以下の値を指定できます：

                THREAD_PRIORITY_HIGHEST         スレッド標準の相対優先順位
                        (2)                     より  2 ポイント高い優先順
                                                位を指定します。
                THREAD_PRIORITY_ABOVE_NORMAL    スレッド標準の相対優先順位
                        (1)                     より  1 ポイント高い優先順
                                                位を指定します。
                THREAD_PRIORITY_NORMAL          スレッド標準の相対優先順位
                        (0)                     を指定します。
                THREAD_PRIORITY_BELOW_NORMAL    スレッド標準の相対優先順位
                        (-1)                    より  1 ポイント低い優先順
                                                位を指定します。
                THREAD_PRIORITY_LOWEST          スレッド標準の相対優先順位
                        (-2)                    より  2 ポイント低い優先順
                                                位を指定します。
                THREAD_PRIORITY_IDLE            基本優先順位として  1 を指
                        (-15)                   定します。
                その他                          UNLHA32.DLL が  API の実行
                                                時に優先順位の設定を行わな
                                                いよう指定します (初期値)。

戻り値
        正常終了時      TRUE を返します。
        エラー時        動作中で変更できなかった場合や，引数が間違いの場合
                        には FALSE を返します。 実際のエラーコードを得るに
                        は UnlhaGetLastError() API を使用してください。

参考
        優先順位を下げても，他に高負荷を掛けるものが少ない場合は，結果とし
        て UNLHA32.DLL が殆どの CPU 時間を占有してしまいますので， THREAD_
        PRIORITY_BELOW_NORMAL 以下の (低い) 順位が指定された場合には，明示
        的に Sleep() API を使用して眠る仕様となっています。 さらに，Unlha-
        SetBackGroundMode() でバックグラウンドモードが指定されている場合に
        は，THREAD_PRIORITY_NORMAL を含む， それ以上の優先順位が指定されて
        いても， 多少は眠るようになっています。

        この API は UnlhaSetWaitLevel() とでも名付けたほうが良さそうな性格
        のもので，優先順位の指定というよりも，ウェイトのほうに重点が置かれ
        ています。

        一般的にノートパソコンはデスクトップに比べて放熱周りの弱いものが多
        く，最高速度でファンを回していても，CPU の負荷が高いと放熱が追いつ
        かず温度が上がる一方…というものが多々見受けられます。一応ある程度
        の温度で上昇が止まるものの，その温度が 60 度以上だったりと，何かの
        拍子で強制的に電源が落とされかねない (実際に落ちることもある) 状態
        では長時間の作業が行えません。

        業務利用では，扱うファイル数が多い，ファイルが大きい…といった理由
        で書庫操作時間の長くなる傾向があるのか，『負荷を下げられないか？』
        といった要望が意外と多く寄せられました。

        そのような経緯で登場したのが UnlhaSetPriority() で，最初に書いたよ
        うに優先順位を下げただけでは負荷軽減には役に立たないことから，ウェ
        イトを入れるようになっています。

-----------------------------------------------------------------------
%W      int WINAPI UnlhaGetLastError(
                        LPDWORD  _lpdwSystemError
                    )
-----------------------------------------------------------------------
順序数  123
要求版  2.39b
機能
        UNLHA32.DLL の最新のエラーコードを取得します。

引数
        _lpdwSystemError        UNLHA32.DLL がエラーコードを設定した時点で
                                のシステムのエラーコード   (GetLastError()
                                API を実行して得られたもの) を格納するため
                                のバッファへのポインタ。

戻り値
        UNLHA32.DLL の最新のエラーコードが返されます。

注意
        UNLHA32.DLL は，各 API の実行開始時に内部的に保持しているエラーコー
        ドのクリアを行います。

参考
        Unlha() などエラーコードを返す API の実行直後では， API の返却値と
        同じ値が得られることになるわけですが， "-jsc" スイッチが指定された
        場合や，UnlhaGetOriginalSizeEx() など処理の正否判定のみを返す  API
        を使用した場合などには，本来のエラーコードを得ることが出来ます。


-----------------------------------------------------------------------
%2. 『統合アーカイバプロジェクト』対応 API について
-----------------------------------------------------------------------

　UNLHA32.DLL は『統合アーカイバプロジェクト』対応 DLL の一つですが， 広く
知られているように， 『統合アーカイバプロジェクト』対応 DLL の仕様というも
のが明確に定められているわけではありません。一応，このドキュメントで説明さ
れている API 群をもっていれば， その範疇に入ると解釈されているようですが，
実際には，各書庫の仕様や参考にしたソースの関係から， 各 DLL で対応している
API がバラバラで統一はとれていません。

　対応アプリ側に立った場合， これらの API の優先度 (必要度) は以下のような
感じになっているようです。

    I.  (ほぼ) 必須であるもの

        %a UnlhaGetVersion                      DLL の版の取得
        %b UnlhaGetRunning                      DLL の実行状況の取得
        %i Unlha                                書庫操作一般
        %j UnlhaCheckArchive                    書庫のチェック
        %q UnlhaOpenArchive                     書庫のオープン
        %r UnlhaCloseArchive                    書庫のクローズ
        %s UnlhaFindFirst                       格納ファイルの検索
        %t UnlhaFindNext                        格納ファイルの検索
        %w UnlhaGetArcOriginalSize              展開サイズの取得
        %x UnlhaGetArcCompressedSize            圧縮サイズの取得
        %y UnlhaGetArcRatio                     圧縮率の取得
        %D UnlhaGetFileName                     ファイル名の取得
        %E UnlhaGetMethod                       メソッドの取得
        %F UnlhaGetOriginalSize                 サイズの取得
        %G UnlhaGetCompressedSize               圧縮サイズの取得
        %H UnlhaGetRatio                        圧縮率の取得
        %I UnlhaGetDate                         更新日の取得
        %J UnlhaGetTime                         更新時間の取得
        %O UnlhaGetAttribute                    属性の取得

    II.  必須となってくるであろうもの

        %w UnlhaGetArcOriginalSizeEx            展開サイズの取得
        %x UnlhaGetArcCompressedSizeEx          圧縮サイズの取得
        %F UnlhaGetOriginalSizeEx               サイズの取得
        %G UnlhaGetCompressedSizeEx             圧縮サイズの取得
        %K UnlhaGetWriteTimeEx                  更新日時の取得
        %K UnlhaGetWriteTime64                  更新日時の取得
        %L UnlhaGetCreateTimeEx                 作成日時の取得
        %L UnlhaGetCreateTime64                 作成日時の取得
        %M UnlhaGetAccessTimeEx                 参照日時の取得
        %M UnlhaGetAccessTime64                 参照日時の取得

    III.  あったほうがよいもの

        %e UnlhaGetCursorMode                   カーソル表示モードの取得
        %f UnlhaSetCursorMode                   カーソル表示モードの設定
        %k UnlhaGetFileCount                    格納ファイル数の取得
        %m UnlhaConfigDialog                    DLL の設定
        %v UnlhaGetArcFileSize                  書庫サイズの取得
        %v UnlhaGetArcFileSizeEx                書庫サイズの取得
        %K UnlhaGetWriteTime                    更新日時の取得
        %L UnlhaGetCreateTime                   作成日時の取得
        %M UnlhaGetAccessTime                   参照日時の取得
        %N UnlhaGetCRC                          チェックサムの取得

    IV.  無くても比較的問題ないもの

        %c UnlhaGetBackGroundMode               DLL の動作モードの取得
        %d UnlhaSetBackGroundMode               DLL の動作モードの設定
        %o UnlhaExtractMem                      メモリーへの展開
        %p UnlhaCompressMem                     メモリーからの格納
        %q UnlhaOpenArchive2                    書庫のオープン
        %u UnlhaGetArcFileName                  書庫名の取得
        %z UnlhaGetArcDate                      書庫更新日の取得
        %A UnlhaGetArcTime                      書庫更新時間の取得
        %Q UnlhaGetArcCreateTimeEx              書庫作成日時の取得
        %R UnlhaGetArcAccessTimeEx              書庫参照日時の取得
        %S UnlhaGetArcWriteTimeEx               書庫更新日時の取得
        %B UnlhaGetArcOSType                    使用 OS の取得
        %C UnlhaIsSFXFile                       SFX タイプの取得
        %T UnlhaGetArcReadSize                  読み込みサイズの取得
        %T UnlhaGetArcReadSizeEx                読み込みサイズの取得
        %P UnlhaGetOSType                       使用 OS の取得
        %V UnlhaSetPriority                     優先度の設定

    V.  無くても殆ど問題とならないもの

        %g UnlhaGetCursorInterval               回転タイミングの取得
        %h UnlhaSetCursorInterval               回転タイミングの設定
        %l UnlhaQueryFunctionList               対応 API の問い合わせ
        %Q UnlhaGetArcCreateTime                書庫作成日時の取得
        %R UnlhaGetArcAccessTime                書庫参照日時の取得
        %S UnlhaGetArcWriteTime                 書庫更新日時の取得
        %U UnlhaSetUnicodeMode                  使用コード設定
        %W UnlhaGetLastError                    エラーコードの取得


-----------------------------------------------------------------------
%3. API で使用されている構造体について
-----------------------------------------------------------------------

　『1. 各 API の説明』でも説明されていますが， UNLHA32.DLL の各 API が使用
している構造体については，すべてワードアラインメントをオフにしておく必要が
ありますので，注意してください。ただし，UNLHA32.H を使用する場合は，Micro-
soft Visual C++，Borland C++，Borland C++ Builder 等のコンパイラーであれば，
改めて設定を行う必要がありません。

-----------------------------------------------------------------------
システム (Win32 API)，ランタイム等で定義されている構造体等
-----------------------------------------------------------------------

------------
  FILETIME
------------
構造体の定義

        typedef struct {
            DWORD               dwLowDateTime;
            DWORD               dwHighDateTime;
        } FILETIME, *LPFILETIME;

構造体のメンバー

        dwLowDateTime           日時を表す  64  ビット符号無し整数値の下位
                                32 ビット。
        dwHighDateTime          日時を表す  64  ビット符号無し整数値の上位
                                32 ビット。

説明

  　様々な Win32 API (タイムスタンプ関連) で扱われる値で，Jan.1,1601 00:00
  :00 からの 100 ナノ秒単位での経過時間が， 2 つの 32 ビット値を結合した構
  造体として構成されたものです。基本的には UTC 時間で扱われます。ちなみに，
  1 秒は 1000 * 1000 * 10 ナノ秒です。UNLHA32.DLL で扱えるタイムスタンプの
  範囲については，『タイムスタンプの補正について』の項を参照してください。

<<参考>>

  　64 ビットの数値基本データ型をもたないコンパイラーを考慮して，2 つの 32
  ビット整数値で構成された構造体として定義されています。

----------------------
  time_t (32 ビット)
----------------------
データ型の定義 (多くの処理系で採用されているもの)

        typedef long time_t;

説明

  　UnlhaGetWriteTime() 等の  API で返される DWORD 値の実体で， Jan.1,1970
  00:00:00 からの経過秒数を表します。 UTC として扱われる点に注意が必要とな
  ります。扱えるタイムスタンプの範囲については，『タイムスタンプの補正につ
  いて』の項を参照してください。

<<重要>>

  　上記の定義を見てお判りのように，多くの処理系では本来 long 値となります
  が，UNLHA32.DLL では， LZH 書庫へ格納される情報に合わせて DWORD 値として
  扱われます。 従って，理論的には (通年としては) 2105 年まで表現できること
  になりますが，2038 年以降を表すデータについては， 他のアプリ等で正常に扱
  われない恐れがあります。

----------------------
  time_t (64 ビット)
----------------------
データ型の定義 (UNLHA32.DLL が返すもの)

        typedef LONGLONG time_t;

説明

  　UnlhaGetWriteTime64() 等の API で返される ULHA_INT64 値の実体で，Jan.1,
  1970 00:00:00 からの経過秒数を表します。UTC として扱われる点に注意が必要
  となります。扱えるタイムスタンプの範囲については，『タイムスタンプの補正
  について』の項を参照してください。

<<重要>>

  　多くの実装系では， 64 ビットの time_t (__time64_t) であっても，1970 年
  より前のタイムスタンプは扱われませんが，UNLHA32.DLL においては，負数とし
  て扱われますので，注意が必要となります。

-----------------------------------------------------------------------
OpenArchive 系 API で定義・使用されている構造体等
-----------------------------------------------------------------------

------------------------------------------------------------------
  ULHA_INT64 (64 ビットの基本データ型をもたないコンパイラーの場合)
------------------------------------------------------------------
構造体の定義

        typedef struct {
            DWORD               LowPart;
            LONG                HighPart;
        } ULHA_INT64, *LPULHA_INT64;

構造体のメンバー

        LowPart                 64 ビット符号付き整数値の下位 32 ビット。
        HighPart                64 ビット符号付き整数値の上位 32 ビット。

説明

  　64 ビットの符号付き整数値を表す UNLHA32.H で定義された構造体です。
  64 ビットの数値基本データ型をもたないコンパイラーを考慮して，  2 つの 32
  ビット整数値で構成された構造体として定義されています。

--------------------------------------------------------------
  ULHA_INT64 (64 ビットの基本データ型をもつコンパイラーの場合)
--------------------------------------------------------------
データ型の定義

        typedef LONGLONG ULHA_INT64, *LPULHA_INT64;

説明

  　64 ビットの数値基本データ型をもつコンパイラーでは LONGLONG となります。

-------------------
  struct _DosDate
-------------------
構造体の定義

        struct {
            unsigned            ft_day   : 5;
            unsigned            ft_month : 4;
            unsigned            ft_year  : 7;
        } _DosDate;

構造体のメンバー

        ft_day                  年月日の日。(1〜31)
        ft_month                年月日の月。(1〜12)
        ft_year                 1980 年からの経過年数。

説明

  　UnlhaGetDate() 等の API で返される WORD 値の実体で，ftime 構造体の上位
  ワードと同じ構造となっています。図示すると：

         15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
        |<--- (年 - 1980) -->|<--- 月 -->|<---- 日 ---->|

  のようになります。ローカルタイムで扱われる点に注意が必要となります。不正
  データや扱えるタイムスタンプの範囲については，『タイムスタンプの補正につ
  いて』の項を参照してください。

-------------------
  struct _DosTime
-------------------
構造体の定義

        struct {
            unsigned            ft_tsec : 5;
            unsigned            ft_min  : 6;
            unsigned            ft_hour : 5;
        } _DosTime;

構造体のメンバー

        ft_tsec                 時分秒の秒を 2 で割ったもの。(0〜29)
        ft_min                  時分秒の分。(0〜59)
        ft_hour                 時分秒の時。(0〜23)

説明

  　UnlhaGetTime() 等の API で返される WORD 値の実体で，ftime 構造体の下位
  ワードと同じ構造となっています。図示すると：

         15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
        |<---- 時 ---->|<------ 分 ----->|<- (秒 / 2) ->|

  のようになります。ft_tsec  に格納される値が秒を 2 で割ったものである点に
  注意してください。また，ローカルタイムで扱われる点にも注意が必要となりま
  す。不正データや扱えるタイムスタンプの範囲については，『タイムスタンプの
  補正について』の項を参照してください。

<<重要>>

  　NTFS 上のファイルや UNIX 等が起源のファイルの場合，00:00:01 といった秒
  の奇数となっていることがありますが，そのようなデータの扱いがプラットフォー
  ムにより異なっている点に注意してください。 Win32s，Windows 95 では丸めの
  際に切り捨てが行われますが，その他では切り上げが行われます。特に注意が必
  要なのは Windows 98 で，API の仕様バグから，SetFileTime() 等では切り上げ
  が行われるにもかかわらず  FileTimeToDosDateTime() では切り捨てられてしま
  います。
  　UNLHA32.DLL では，Win32 API を使用しないことにより， Windows 98 におい
  ても切り上げた数値が返されるようになっています。(Ver 1.32 以降)

------------------
  INDIVIDUALINFO
------------------
構造体の定義

        typedef struct {
                DWORD           dwOriginalSize;
                DWORD           dwCompressedSize;
                DWORD           dwCRC;
                UINT            uFlag;
                UINT            uOSType;
                WORD            wRatio;
                WORD            wDate;
                WORD            wTime;
                TCHAR           szFileName[FNAME_MAX32 + 1];
                TCHAR           dummy1[3];
                TCHAR           szAttribute[8];
                TCHAR           szMode[8];
        } INDIVIDUALINFO;

構造体のメンバー

        dwOriginalSize          ファイルのサイズ。
        dwCompressedSize        圧縮後のサイズ。
        dwCRC                   格納ファイルのチェックサム用 CRC。
        uFlag                   展開やテストを行った場合，格納ファイル毎の
                                処理結果が返されます。 コードは Unlha() が
                                返すものと同じ。その他の場合は 0。
        uOSType                 このファイルの作成に使われた OS。
                                         0      MS-DOS
                                         2      UNIX
                                         4      旧 MAC-OS
                                         5      OS/2
                                        10      その他
                                        11      OS9 (MAC の新型ではない)
                                        12      OS/68K
                                        13      OS/386
                                        14      HUMAN
                                        15      CP/M
                                        16      FLEX
                                        17      Runser
                                        18      Windows NT 系 OS
                                        19      Windows 95 系 OS
                                        -1      エラー
        wRatio                  パーミル (千分率) で表された圧縮率。
        wDate                   ftime の上位ワードと同じ次の構造で現された
                                日付 (ローカルタイム)。

                                    struct {
                                        unsigned ft_day   : 5;
                                        unsigned ft_month : 4;
                                        unsigned ft_year  : 7;
                                    } _DosDate;

                                図示すると

                          15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
                         |<--- (年 - 1980) -->|<--- 月 -->|<---- 日 ---->|

                                のようになります。
                                ft_year に格納される値は 1980 年からの経過
                                年数です。したがって，理論的には 2107 年いっ
                                ぱいまで表現できることになります。
        wTime                   ftime の下位ワードと同じ次の構造で現された
                                時刻 (ローカルタイム)。

                                    struct {
                                        unsigned ft_tsec : 5;
                                        unsigned ft_min  : 6;
                                        unsigned ft_hour : 5;
                                    } _DosTime;

                                図示すると

                          15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
                         |<---- 時 ---->|<------ 分 ----->|<- (秒 / 2) ->|

                                のようになります。
                                ft_tsec  に格納される値が秒を 2 で割ったも
                                のである点に注意してください。

                                <<重要>>
                                NTFS 上のファイルや  UNIX 等が起源のファイ
                                ルの場合， 00:00:01 等秒の奇数である場合が
                                当然ありますが，そのようなデータの扱いがプ
                                ラットフォームにより異なっていることに注意
                                してください。 Win32s，Windows 95 では丸め
                                の際に切り捨てが行われますが，その他では切
                                り上げが行われます。  特に注意が必要なのは
                                Windows 98 であり，API のバグから，SetFile-
                                Time()  等では切り上げが行われるにもかかわ
                                らず FileTimeToDosDateTime()  では切り捨て
                                られてしまいます。
                                UNLHA32.DLL では，Win32 API を使用しないこ
                                とにより， Windows 98 においても切り上げた
                                数値が返されるようになっています。
                                (Ver 1.32 以降)
        szFileName              格納ファイルの名前。
        szAttribute             格納ファイルの属性。'l' コマンド等でのリス
                                ト出力と同じ。
        szMode                  ダミー。UNLHA32.DLL では圧縮形式の文字列が
                                入っています。

説明

  　定義をみれば分かるとおり， INDIVIDUALINFO 構造体を使用する限りにおいて
  は，タイムスタンプは ftime の制度でしか得られません。 正確なタイムスタン
  プを得たい場合は API を使用する必要があります。

  　この構造体は UNLHA32.DLL 固有のものであり，他のアーカイバー関連 DLL で
  使用できるとは限りませんし，サイズ等についても 32 ビット整数でしか情報を
  得られません。 従って，情報の取得にはなるべく API を使用するようにしてく
  ださい。


-----------------------------------------------------------------------
%4. レジストリーの設定値
-----------------------------------------------------------------------

　Win32s 環境では， 名前がすべてキーとなり値も全て REG_SZ となります。 Win
9x や NT 等とはシステムの仕様が異なっていますので，注意してください。

　全て説明すると却って混乱するので，一部しか記述していません。(^^;;


        HKEY_CURRENT_USER\\Software\\ArchiverDll\\Common

        　"Common" から予想されるように，他の『統合アーカイバプロジェクト』
        に準拠した DLL の設定による影響を受ける場合があります。 当然ながら
        UNLHA32.DLL がこれらの値を設定した場合には， 他の DLL に影響を及ぼ
        す可能性があることになります。

                DefaultDir : REG_SZ

                        基準ディレクトリー。最後は '\' か ':' で終わってい
                        る必要があります。

                DirectoryMode : REG_DWORD

                        展開時に絶対パスを使用するか，相対パスを使用するか
                        のフラグ。

                                0 :     相対パス。 "-jf0" を指定した場合と
                                        同じで，絶対パスについては相対パス
                                        に強制変換されます。
                                1 :     絶対パス。（既定値）

                BadPathLevel : REG_DWORD

                        不正パスチェックのチェックレベル。

                                0 :     チェックなし。"-jsp0" を指定した場
                                        合と同じです。
                                1 :     レベル 1。"-jsp1" を指定した場合と
                                        同じで，基準ディレクトリーを越えて
                                        遡るパスを不正とします。(既定値)
                                3 :     レベル 2。"-jsp3" を指定した場合と
                                        同じで，レベル 1 のチェックに加え，
                                        絶対パスを不正扱いとします。

                        これ以外の値を指定するとレベル 1 とみなされます。

                OverWriteMode : REG_DWORD

                        展開ファイルの上書き時の動作。

                                0 :     常に上書き。 "-jyo" を指定した場合
                                        と同じです。
                                1 :     上書きするか確認。(既定値)
                                2 :     上書きしません。"-jn" を指定した場
                                        合と同じです。

                ExtractAttribute : REG_DWORD

                        属性も展開 (復元) するかどうかのフラグ。

                                0 :     展開しません。
                                1 :     展開します。(既定値)

                JunkDirectory : REG_DWORD

                        'x' 命令を指定時にも 'e'  命令と見なして実行するか
                        どうかのフラグ。

                                0 :     'x' 命令を実行。(既定値)
                                1 :     'e' 命令を実行。"-gj" を指定した場
                                        合と同じです。


        HKEY_CURRENT_USER\\Software\\ArchiverDll\\UNLHA32

        　UNLHA32.DLL が固有の情報として設定・利用するものです。基本的にア
        プリケーション側で，ここでの情報を使用するかどうかを選べるので，こ
        こに設定したとおり動作するとは限りません。

                Unlha32Version : REG_DWORD

                        UnlhaGetVersion() の返却値をユーザーが指定したい場
                        合に設定します。こちらは，全てのアプリに影響します。

                                119 :   この場合 119 を返すようになります。
                                        Ver 1.19 の意味。

                UseMFile : REG_DWORD

                        メモリマップドファイルを使用してファイルの入出力を
                        行うかどうかのフラグ。通常，UNLHA32.DLL は以下の場
                        合に可能であればメモリマップドファイルを利用します。
                        Windows 2K 以降の NT 系 OS のみが該当します。

                                読込時 ：常に。
                                書込時 ：ローカル上の固定ドライブの場合。

                        レジストリーでの指定は以下のとおりです。

                                0 :     使用しません。
                                1 :     使用します。(既定値)

                FDDCheck : REG_DWORD

                        FDD ドライブの場合に上記の合計モードでのグラフ表示
                        の抑制を行うかどうかのフラグ。HDD 等のデバイスでは
                        書庫の二度読みを行ってもさほど気にならない程度です
                        が，FDD ではかなり待たされることになるのでデフォル
                        トでは通常表示を行うようになっています。

                                0 :     抑制を行いません。
                                1 :     抑制を行います。(既定値)

                bAlwaysOpen : REG_DWORD

                        UnlhaFindFirst/Next() で書庫ファイルの開閉を行わな
                        いようにします。

                                0 :     開閉を行います。
                                1 :     UnlhaFindClose()  が実行されるまで
                                        開いたままとします。（既定値）

                ForceUseAllPath : REG_DWORD

                        厳密なファイルサーチをするかどうかのフラグ。

                                0 :     行いません。(既定値)
                                1 :     行います。 "-p" を指定した場合と同
                                        じです。

                DiskSpaceCheck : REG_DWORD

                        展開先の空き容量の確認をするかどうかのフラグ。

                                0 :     確認しません。(既定値)
                                1 :     確認します。"-jd" を指定した場合と
                                        同じです。

                MakeDirectoryMode : REG_DWORD

                        ディレクトリー作成時の確認をするかどうかのフラグ。

                                0 :     確認します。(既定値)
                                1 :     確認しません。"-jyc"  を指定した場
                                        合と同じです。

                TotalBar : REG_DWORD

                        展開ファイルの合計を 100% とした進捗グラフを表示す
                        るかどうかのフラグ。ただし，書庫ファイルを２度読み
                        することになるので処理に時間がかかります。

                                0 :     表示しません。(既定値)
                                1 :     表示します。

                FVMode : REG_DWORD

                        展開ファイル名とグラフだけの簡易表示とするかどうか
                        のフラグ。

                                0 :     通常表示を行います。(既定値)
                                1 :     簡易表示を行います。


                UseDefaultChar : REG_DWORD

                        UNLHA32.DLL が WideCharToMultiByte() API  を使用し
                        て行う  Unicode からマルチバイト文字への変換の際の
                        変換方法を指定するフラグ。

                                0 :     当該コードページで表現できない文字
                                        について，'_' の文字への変換を行い
                                        ます。実際には，dwFlags と
                                        lpDefaultChar  に  WC_NO_BEST_FIT_
                                        CHARS， "_" をそれぞれ指定します。
                                        (既定値)
                                1 :     当該コードページで表現できない文字
                                        について，システム既定の文字への変
                                        換を行います。dwFlags と lpDefault-
                                        Char に WC_NO_BEST_FIT_CHARS，NULL
                                        をそれぞれ指定します。
                                        このスイッチを利用することにより，
                                        "(c)2006s.BIN" (ただし (c) は Uni-
                                        code のコード U+00A9) といった当該
                                        コードページで表現できない文字を
                                        もった名前のメンバーについて，名前
                                        情報として "?2006s.BIN" が得られる
                                        ようになることから，ANSI 版 API を
                                        使用しているアーカイバー等でも，当
                                        該メンバーを (擬似的にですが) 直接
                                        扱えるようになります。が，得られる
                                        のがワイルドカード文字列であること
                                        から，"?2006s.BIN" を指定すれば，
                                        "A2006s.BIN"  といったメンバーも扱
                                        われてしまいます。その点を理解した
                                        上で使用するようにして下さい。
                                2 :     当該コードページで表現できない文字
                                        について，近い表現となるマルチバイ
                                        ト文字への変換を行います。上記の例
                                        であれば， "(c)2006s.BIN"  ((c) は
                                        Unicode のコード U+00A9) が "c2006
                                        s.BIN" へ変換されます。 Unicode で
                                        しか表現できないハートマーク (Uni-
                                        Code のコード U+2665) のような文字
                                        については '_' へ変換されます。
                                        dwFlags と lpDefaultChar に 0，"_"
                                        をそれぞれ指定します。
                                        Win32 ANSI 版 API を使用した場合と
                                        同様の変換結果を得たい場合に使用で
                                        きますが，使用はお勧めしません。

                        このフラグは Windows 98/Me と Windows 2K 以降の NT
                        系 OS のみで有効となります。 Windows 95 や Windows
                        NT 3.x/4.0 では，WideCharToMultiByte() API の仕様 [*1]
                        から，2 の変換しか行えません。
                        なお，上記のフラグ説明は，日本語環境 (コードページ
                        932) を前提として行っています。
                        --------------------------------------------------
                        [*1]  WC_NO_BEST_FIT_CHARS フラグは  Windows 95 等
                              では無効  (ERROR_INVALID_FLAGS エラーとなる)
                              となっています。一見 WC_COMPOSITECHECK |
                              WC_DEFAULTCHAR  といったようなフラグ指定で代
                              替処理を行えそうに思えますが，WC_DEFAULTCHAR
                              は『例外時のみ有効』なもので，無理矢理強引な
                              組み合わせで合成が行われたアクサン付き母音文
                              字等であれば別ですが，L'(c)' ((c) は Unicode
                              の U+00A9) の文字や  NTFS ファイルシステムが
                              通常作成する合成文字は， WC_DEFAULTCHAR によ
                              る例外の対象とはなりません (そもそも例外では
                              ない)。


        HKEY_CURRENT_USER\\Software\\ArchiverDll\\UNLHA32\\Version

        　上記の Unlha32Version と異なり，指定したソフトに対してのみ特定の
        版数を返すよう設定します。

                x : REG_SZ

                        ソフトのモジュール名と版数を指定します。  x につい
                        ては，0〜31 までが指定できます。モジュール名につい
                        ては，例えば LHMelt であれば "LHMELT" のように拡張
                        子を省略して指定する必要があります。

                            例 :        0 : LHMELT,140

                               LHMelt に対して 140 (1.40) を返すように指定


        HKEY_CURRENT_USER\\Software\\ArchiverDll\\UNLHA32\\UseOldLogList

        　旧形式ログ (改行コードが '\n') を使用するソフトを指定します。 GV
        については，暫定措置で強制的に指定されています。

                x : REG_SZ

                        ソフトのモジュール名を指定します。  x については，
                        0〜31 までが指定できます。モジュール名については，
                        例えば LHMelt であれば "LHMELT" のように拡張子を省
                        略して指定する必要があります。


        HKEY_CURRENT_USER\\Software\\ArchiverDll\\UNLHA32\\CauseOldGfList

        　"-u" 及び "-gf" スイッチについて，古い仕様の動作を行わせるソフト
        を指定します。WinFM32，WinFM2K，WinLM32 については，暫定措置で強制
        的に指定されています。

                x : REG_SZ

                        ソフトのモジュール名を指定します。  x については，
                        0〜31 までが指定できます。モジュール名については，
                        例えば LHMelt であれば "LHMELT" のように拡張子を省
                        略して指定する必要があります。


-----------------------------------------------------------------------
%5. Unlha()の返すエラーコードとその意味
-----------------------------------------------------------------------

■警告    ：通常，該当ファイルについての処理をスキップするだけで，基本的に
            実行を中止することはありません。 "-jse" スイッチでエラーとする
            ことができます。

ERROR_DISK_SPACE        (0x8005)
                        書庫を作成したりファイルを展開するための空き容量が
                        足りなかったことを示します。格納時はエラーとなりま
                        すが，展開時は当該格納ファイルの展開をスキップして
                        次のファイルの展開に移ります。
ERROR_READ_ONLY         (0x8006)
                        読込専用属性の既存のファイルが存在するため，ファイ
                        ルの展開等が行えなかったことを示します。 CD-ROM 等
                        に書き込もうとした…といったパターンによるものが意
                        外と多いです。＞質問メール
ERROR_USER_SKIP         (0x8007)
                        展開先のディレクトリーチェックや格納ファイルのパス
                        情報によるディレクトリー再構築時のディレクトリー作
                        成確認に対して，ユーザが作成を了承しなかったことを
                        示します。
                        通常は警告扱いですが，"-jse2" が指定された場合には
                        エラー扱いとなり，このエラーが返されます。
ERROR_UNKNOWN_TYPE      (0x8008)
                        このエラーコードは  UNARJ(32).DLL 用のものですが，
                        UNLHA32.DLL では，"-jse2" スイッチにより特殊属性等
                        へのファイル上書きをエラー扱いとした場合に，便宜上
                        このコードを返すようになっています。
                        本来なら別のコードを返さないといけないのですが，こ
                        のエラーコードを想定しているアプリが存在する等，過
                        去の経緯から，そのままになっています。また，却って
                        混乱することから，エラーメッセージについても， UN-
                        ARJ(32).DLL と同じものが表示されるようになっていま
                        すので，注意してください。
ERROR_FILE_CRC          (0x800C)
                        展開された  (またはチェックした) ファイルの CRC が
                        書庫の情報と異なっていることを示します。要は書庫ファ
                        イルのデータ化けです。
ERROR_FILE_OPEN         (0x800D)
                        (書庫を除く) 各種ファイルのオープン時や GetFile-
                        Time() API 呼び出しのためなど，内部的な CreateFile
                        () API 呼び出しが失敗したことを示します。
                        圧縮・格納しようとしたファイルが同様のエラーとなっ
                        た場合には ERROR_SHARING が返されます。
ERROR_MORE_FRESH        (0x800E)
                        より新しいファイルなど，展開先に既存のファイルが存
                        在することを示します。
                        "-u" スイッチや "-gf" スイッチの指定によって意味が
                        異なり，必ずしも『新しいファイルが存在すること』を
                        示すものではありません。
ERROR_NOT_EXIST         (0x800F)
                        "-gf" スイッチが指定された場合など，必要な既存の
                        ファイルが展開先に存在しないことを示します。
ERROR_ALREADY_EXIST     (0x8010)
                        "-jn1" スイッチが指定された場合に，(タイムスタンプ
                        等にかかわらず) 同名の既存のファイルが展開先に存在
                        していることを示します。

■エラー  ：致命的なエラーで多くはその時点で実行を中止します。

ERROR_MAKEDIRECTORY     (0x8012)
                        ディレクトリーの作成に失敗したことを示します。
ERROR_CANNOT_WRITE      (0x8013)
                        WriteFile() API 呼び出しの失敗によるファイル書き込
                        みエラー全般を示します。
                        書庫操作中に作業ディレクトリーの存在するディスクの
                        空きがなくなった結果…というパターンが意外と多くを
                        占めます。
ERROR_HUFFMAN_CODE      (0x8014)
                        書庫の破損のため，当該ファイルのハフマン圧縮用テー
                        ブルの初期化が正常に行えなかったことを示します。
                        簡単に言えば『格納ファイルが壊れている』ということ
                        です。
ERROR_HEADER_CRC        (0x8016)
                        書庫のヘッダに記録されている  CRC と実際に読み込ん
                        だヘッダの CRC が一致しなかったことを示します。
                        こちらはヘッダのデータ化けを表しますが，書庫が改竄
                        された可能性もあります。
ERROR_HEADER_BROKEN     (0x8017)
                        書庫のヘッダが破損していることを示します。
                        現在の UNLHA32.DLL では， 書庫ヘッダの破損について
                        エラーコードが細分化されているため，このエラーが返
                        されることはありません。
ERROR_ARC_FILE_OPEN     (0x8018)
                        新規書庫や既存書庫のオープンに失敗したことを示しま
                        す。
                        書庫操作時には，操作対象となる書庫が作業ファイルの
                        一つとして変名 (又はコピー) された上で使用されるこ
                        とから，  作業書庫のファイル名が報告されていても，
                        (実質)  操作対象の書庫についてのエラーを意味してい
                        る場合があります。
                        実際に ERROR_ARC_FILE_OPEN が返されるのは， 以下の
                        場合です：

                 ・新規の書庫作成時において，書庫書込のため MyCreate-
                   File() で書庫を開こうとした際にエラーとなった場合。
                 ・操作対象書庫の退避が必要かどうかの判断の一つとして，
                   操作対象書庫が存在するかどうかのチェックを
                   MyCreateFile() で行った後の MyCloseFileHandle() に
                   失敗した場合。
                 ・操作対象書庫を退避 (移動又はコピー) するための
                   MoveFile() API 呼び出しが失敗した場合。
                 ・書庫のタイムスタンプを記憶しておくための MyGetFile-
                   Time() 呼び出しに伴う MyCreateFile() 及び MyClose-
                   FileHandle() が失敗した場合。 退避後の場合は作業書
                   庫名で報告されます。
                   その他自己解凍書庫チェック等をはじめとして，  各種
                   チェックのために使用する API の中には， ファイル名
                   を指定するもの (要は内部でファイルが開かれる) が存
                   在するため，『ファイルを開いたままハンドルを使用し
                   て処理』する仕様とはなっていません。
                 ・書庫読込のため MyCreateFile() で書庫を開こうとした
                   際にエラーとなった場合。退避後の場合は作業書庫名で
                   報告されます。
                 ・書庫の読み書きやタイムスタンプの取得・設定等のエラー
                   については，それぞれのエラーコードが返されます。

ERROR_NOT_ARC_FILE      (0x8019)
                        Unlha() に渡されたコマンド列で書庫が指定されていな
                        い (又は UNLHA32.DLL が書庫名を認識できなかった)
                        ことを示します。
                        拡張子を省略した場合など，Unlha() が書庫と判断でき
                        ないこともありますが，指定ミスであることが多いです。
ERROR_CANNOT_READ       (0x801A)
                        ReadFile() API  呼び出しの失敗によるファイル読み込
                        みエラー全般を示します。
ERROR_FILE_STYLE        (0x801B)
                        指定された書庫が  LZH 書庫ではない (又は  UNLHA32.
                        DLL が 書庫と認識できなかった) ことを示します。
ERROR_COMMAND_NAME      (0x801C)
                        Unlha() に渡されたコマンド列に誤りがあることを示し
                        ます。
                        コマンドそのものやファイル指定等に省略値が存在する
                        ことや，書庫指定やスイッチ指定等では別のエラーコー
                        ドが返されること等から，このエラーが返されるのは，
                        Unlha() 等の _szCmdLine にNULL  が渡された場合のみ
                        です。
ERROR_MORE_HEAP_MEMORY  (0x801D)
                        作業用ヒープメモリーの確保 (ランタイムの malloc 呼
                        び出し) に失敗したことを示します。
ERROR_ENOUGH_MEMORY     (0x801E)
                        処理結果を返すためのバッファの確保  (GlobalAlloc()
                        API 呼び出し) に失敗したことを示します。
                        現在の UNLHA32.DLL では使用されていません。
ERROR_ALREADY_RUNNING   (0x801F)
                        すでに UNLHA32.DLL が動作中で API の多重呼び出しが
                        発生したことを示します。
ERROR_USER_CANCEL       (0x8020)
                        ユーザが明示的に処理を中止したことを示します。
ERROR_HARC_ISNOT_OPENED (0x8021)
                        UnlhaOpenArchive() API を呼び出さずに  HARC ハンド
                        ルを使用した (又は HARC ハンドルの示すデータ領域が
                        破壊された) ことを示します。
                        UnlhaOpenArchive()  で書庫とハンドルを関連付ける前
                        に  UnlhaFindFirst() 等の API を使用した…という例
                        が殆どを占めます。
ERROR_NOT_SEARCH_MODE   (0x8022)
                        UnlhaGetFirst() を呼び出さずに UnlhaGetNext() が呼
                        び出された。または，これらを呼び出す前に UnlhaGet-
                        FileName() 等の API が呼び出されたことを示します。
ERROR_NOT_SUPPORT       (0x8023)
                        本来は UNLHA32.DLL でサポートされていない API の使
                        用されたことを示すコードですが，当該環境で使用でき
                        ない機能を実行しようとした場合にも返されます。
ERROR_TIME_STAMP        (0x8024)
                        "-jo" スイッチでの日時指定に誤りがあることを示しま
                        すが，このコードが実際に返されることはありません。
                        警告としてメッセージがログに出力されるのみです。
ERROR_TMP_OPEN          (0x8025)
                        書庫操作時に使用する作業ファイルが開けなかったこと
                        を示します。
                        書庫操作時には，操作対象となる書庫が作業ファイルの
                        一つとして変名 (又はコピー) された上で使用されるこ
                        とから， このエラーが返されている場合でも， (実質)
                        操作対象の書庫についてのエラーを意味している場合が
                        あります。
                        実際に ERROR_TMP_OPEN が返されるのは，以下の場合で
                        す：

                 ・操作対象書庫の退避先となる作業書庫がすでに存在する
                   (動的命名で作成できなかった場合には固定名となる)
                   かどうかを MyCreateFile() でチェックした結果，既存
                   のファイルが存在した場合に，

                        1 : チェック後の MyCloseFileHandle() が失敗し
                            た場合。
                        2 : 既存のファイルを削除するための DeleteFile
                            () API 呼び出しが失敗した場合。

                 ・書庫操作の結果を格納する作業書庫を作成するための
                   MyCreateFile() に失敗した場合。
                 ・(書庫操作の結果である) 作業書庫のサイズが，書庫の保存先
                   のファイルシステムで扱えるファイルサイズを超えてしまっ
                   た場合。

                        以前の版では，作業書庫の命名規則がオリジナル (LHA)
                        に近いものであったことから，環境によっては，作業書
                        庫の競合が比較的高い確率で発生する関係上， (前者に
                        より)  ERROR_TMP_OPEN エラーが返されることがありま
                        した。 1.90a で GetTempFileName() API を使用するよ
                        うに変更されましたが，競合の確率が下がっているかど
                        うかは判りません (手元の環境では発生しないので)。
ERROR_LONG_FILE_NAME    (0x8026)
                        (ワイルドカード等で指定された場合などの)  格納ファ
                        イルリスト作成時に，当該書庫で正常に扱えない可能性
                        のある長い (h2 形式では 259 バイトを超える) パス情
                        報 (ファイル名を含む) をもったファイルが見つかった
                        ことを示します。
                        当該ファイル (及びディレクトリー) についてスキップ
                        すればよいような気もしますが，オリジナルに合わせて
                        エラー扱いされるようになっています。
                        h0 形式書庫の場合に遭遇することが多いです。HEADER.
                        TXT を見ると解りますが， h0 形式では登録できるパス
                        情報の長さが短い (64 バイト)…というのが理由。
ERROR_ARC_READ_ONLY     (0x8027)
                        読込専用属性の書庫に対して書庫操作を行おうとしたこ
                        とを示します。
ERROR_SAME_NAME_FILE    (0x8028)
                        (特にパス情報を無視させた場合などに)  書庫に同じ名
                        前で格納される複数のファイルを格納しようとしたこと
                        を示します。
ERROR_NOT_FIND_ARC_FILE (0x8029)
                        操作対象書庫が見つからないことを示します。
                        このエラーが返されるのは，大きく分けて次の 2 つです：

                 ・新規作成時以外の対象となる書庫が必要な操作において，
                   指定した書庫が見つからなかった場合 (ワイルドカード
                   指定等の関係もあって，実際に書庫を扱う前に MyFind-
                   first() での存在チェックを行っています)。
                 ・'j'  命令で追加対象として指定された書庫が開けなかっ
                   た場合。

ERROR_RESPONSE_READ     (0x802A)
                        (開けなかった場合等を含めて)  指定されたレスポンス
                        ファイルからの読込に失敗したことを示します。
ERROR_NOT_FILENAME      (0x802B)
                        対象ファイルを指定する必要のある操作において，対象
                        ファイルが指定されていないことを示します。
                        このエラーが返されるのは， 大きく分けて次の 2 つで
                        す：

                 ・ファイル指定の省略が許されていない  'd' コマンドで
                   ファイル指定が省略された場合。
                 ・UnlhaExtractMem()，UnlhaCompressMem()  の各 API で
                   _szCmdLine が NULL か何も含まれていない場合。

ERROR_TMP_COPY          (0x802C)
                        書庫操作の結果を操作対象書庫として保存するためのコ
                        ピー処理に失敗したことを示します。
                        書庫操作時には，操作対象となる書庫が，退避を兼ねて
                        作業ファイルの一つとして変名 (又はコピー) された上
                        で (その作業書庫が) 使用され，また，書庫操作の結果
                        として (別の) 作業書庫が作成されます。操作対象の書
                        庫が直接更新されるわけではありません。
                        従って，操作終了時に必ず (操作結果としての) 作業書
                        庫を対象書庫として保存するためのコピー  (又は変名)
                        処理が発生します。
                        このエラーは，そのコピー (変名) 処理に失敗したこと
                        を示し，実際には次の場合に返されます：

                 ・書庫操作に書庫の更新が伴わなかった場合は，退避され
                   た作業書庫が対象書庫として MoveFile() API により復
                   元されますが，その MoveFile() API 呼び出しが失敗し
                   た場合。
                 ・更新を伴った場合は，操作結果としての作業書庫が対象
                   書庫として保存されますが，その際に，

                        1 : 保存先として対象書庫を開く際の  MyCreate-
                            File() が失敗した場合。
                        2 : 保存元として作業書庫を開く際の   myopen2()
                            (実体は MyCreateFile()) が失敗した場合。
                        3 : 保存終了時の  MyCloseFileHandle() が失敗し
                            た場合。
                        4 : 処理開始時に記憶しておいたタイムスタンプを
                            書き込むための， MyCreateFile()， MyClose-
                            FileHandle() に失敗した場合。

                 ・書庫の読み書きやタイムスタンプの取得・設定等のエラー
                   については，それぞれのエラーコードが返されます。

                        このエラーの場合，操作対象の書庫が失われていること
                        から『どの作業書庫が (操作結果としての) 操作対象書
                        庫と同等のものなのか？』を示す必要があります。その
                        ため，実際にエラーを起こしているファイルにかかわら
                        ず，常に操作対象書庫として代用が可能であるファイル
                        をエラー対象ファイルとして報告する仕様となっていま
                        す。
                        このエラーの場合，UNLHA32.DLL は (操作対象書庫と同
                        等の) 作業書庫の削除を行わないので，ユーザは残され
                        ている作業書庫を操作対象書庫として復元することが可
                        能です。
ERROR_EOF               (0x802D)
                        書庫の読込時に，予期しない箇所でファイルの終わりが
                        検知されたことを示します。
                        エラーコードが細分化されたことから，現在の UNLHA32.
                        DLL では，このエラーが返されることはありません。
ERROR_ADD_TO_LARC       (0x802E)
                        操作対象として指定された書庫が，書庫操作の許されて
                        いない，LArc や Lhasa 等の自己解凍書庫であることを
                        示します。
ERROR_TMP_BACK_SPACE    (0x802F)
                        書庫操作の結果を操作対象書庫として保存するための空
                        き容量が存在していないことを示します。
                        書庫操作時には，操作対象となる書庫が，退避を兼ねて
                        作業ファイルの一つとして変名 (又はコピー) された上
                        で (その作業書庫が) 使用され，また，書庫操作の結果
                        として (別の) 作業書庫が作成されます。操作対象の書
                        庫が直接更新されるわけではありません。
                        従って，操作終了時に必ず (操作結果としての) 作業書
                        庫を対象書庫として保存するためのコピー  (又は変名)
                        処理が発生します。
                        このエラーは， (コピーが行われる場合に) 作業書庫を
                        対象書庫として保存するための空き容量が存在していな
                        い場合に返されます。
                        その際，操作対象の書庫が失われていることから『どの
                        作業書庫が (操作結果としての) 操作対象書庫と同等の
                        ものなのか？』を示す意味で，操作対象書庫として代用
                        が可能であるファイルをエラー対象ファイルとして報告
                        する仕様となっています。
                        このエラーの場合，UNLHA32.DLL は (操作対象書庫と同
                        等の) 作業書庫の削除を行わないので，ユーザは残され
                        ている作業書庫を操作対象書庫として復元することが可
                        能です。

                        参考   : 空き容量について

                          作業書庫の書き戻しを行う時点では， 多くの場合，
                          次の作業書庫がディスク上に存在しています。

                1 : 操作対象書庫を変名した作業書庫。操作前の書庫と同等のも
                    の (というか，そのもの) で，操作対象書庫と同じディレク
                    トリに作成されます。
                2 : 操作結果として作成された作業書庫。操作後の書庫と同等の
                    もので，作業ディレクトリーに作成されます。

                          操作対象書庫の存在するドライブと作業ディレクト
                          リーの存在するドライブが異なっている場合は，

                3 : 操作結果として書き戻される操作対象書庫

                          が作成され， 最終的に 2 の操作後の書庫と同じサイ
                          ズになります。
                          従って，多くの場合，書庫操作の際には『操作後の書
                          庫のサイズ』の空き容量が必要ということになります。
                          "-jsa1" が指定された場合は，1 の作業書庫が，書き
                          戻し処理の後に削除されるため，『操作前の書庫のサ
                          イズ + 操作後の書庫のサイズ』の空き容量が必要と
                          なります。
                          さらに， 状況によっては変名を目的とした MoveFile
                          () API 内部でコピーと同等の処理が行われたり，
                          MoveFile() API  呼び出しが失敗し同じドライブ間で
                          のコピーが行われたりすることから， 最悪の場合
                          『操作前の書庫のサイズ + (操作後の書庫のサイズ *
                          2)』の空き容量が必要となります。
                          空き容量に対して，比較的操作対象書庫が大きい場合
                          は，空き容量に十分注意して書庫操作を行ってくださ
                          い。
ERROR_SHARING           (0x8030)
                        圧縮・格納しようとしたファイルが共有エラーなどでア
                        クセスできなかったことを示します。
                        排他処理で引っかかる場合が殆どです。ウィルスチェッ
                        ク等の監視ソフト等と衝突している…といったような場
                        合が多く，特に『重いネットワーク上のファイル』を扱っ
                        た場合などに確率が高くなります。
ERROR_NOT_FIND_FILE     (0x8031)
                        圧縮・格納しようとしたファイルが (処理前の格納対象
                        リスト作成時には見つかったにもかかわらず) 見つから
                        なかったことを示します。
ERROR_LOG_FILE          (0x8032)
                        "-gl" スイッチが指定された場合に，ログファイルへの
                        書き込みが失敗したことを示します。
ERROR_NO_DEVICE         (0x8033)
                        (CD-ROM や FD が挿入されていない場合など) デバイス
                        (ドライブ) にアクセスできなかったことを示します。
ERROR_GET_ATTRIBUTES    (0x8034)
                        ファイル処理全般として  MyGetFileAttributes() が失
                        敗したことを示します。
ERROR_SET_ATTRIBUTES    (0x8035)
                        ファイル処理全般として  SetFileAttributes() API 呼
                        び出しに失敗したことを示します。
ERROR_GET_INFORMATION   (0x8036)
                        ファイルの情報取得しての Myfindfirst()，GetDisk-
                        FreeSpace() API，GetDiskFreeSpaceEx() API，GetFile-
                        Time() API 呼び出しに失敗したことを示します。
ERROR_GET_POINT         (0x8037)
                        ファイル処理全般として，Myftell()，(ポインタ取得の
                        ための)  SetFilePointer() API 等の呼び出しが失敗し
                        たことを示します。
ERROR_SET_POINT         (0x8038)
                        ファイル処理全般として Myrewind()， MySetFile-
                        Pointer2()，Myfseek() 等の呼び出しが失敗したことを
                        示します。
ERROR_CONVERT_TIME      (0x8039)
                        FILETIME，time_t 間，FILETIME，SYSTEMTIME 間，
                        ftime， FILETIME 間，(FILETIME での) ローカル，UTC
                        間，等で，タイムスタンプの変換が失敗したことを示し
                        ます。
ERROR_GET_TIME          (0x803A)
                        各種ファイルのタイムスタンプ取得に失敗したことを示
                        します。
ERROR_SET_TIME          (0x803B)
                        各種ファイルのタイムスタンプ設定に失敗したことを示
                        します。
ERROR_CLOSE_FILE        (0x803C)
                        開いたファイルを閉じることができなかったことを示し
                        ます。
ERROR_HEAP_MEMORY       (0x803D)
                        ERROR_MORE_HEAP_MEMORY とは異なり，(最終的にランタ
                        イムの malloc() で) 取得したヒープメモリーの解放が
                        正常に行えなかったことを示します。パラメータの指定
                        ミスや UNLHA32.DLL のバグにより， バッファが破壊さ
                        れた状態です。
ERROR_HANDLE            (0x803E)
                        (UNLHA32.DLL が内部で呼び出している) FindClose()
                        API の呼び出しに失敗したことを示します。
ERROR_TIME_STAMP_RANGE  (0x803F)
                        通常  UNLHA32.DLL はファイルシステムの仕様やシステ
                        ムの制限等により正常に扱えない恐れのあるタイムスタ
                        ンプが渡された場合には，正常に扱えるデータに補正す
                        るようになっていますが，"-jsf0" が指定された場合に
                        は，補正を行わずエラーを返すようになります。UNLHA-
                        32.DLL  が安全であると認識している範囲外のタイムス
                        タンプが扱われたことを示します。
                        補正関連については，COMMAND.TXT の "-jsf" スイッチ
                        の項を参照してください。
ERROR_MAKE_ARCHIVE      (0x8040)
                        "-jsv1" が指定した場合に行われる，書庫操作後の正常
                        性チェックに通らなかったことを示します。
ERROR_NOT_CONFIRM_NAME  (0x8041)
                        拡張ヘッダ長から逆算されるパス名  (及びファイル名)
                        の長さと，実際に記録されている名前の長さとが一致し
                        ないことを示します。
ERROR_UNEXPECTED_EOF    (0x8042)
                        ヘッダ長で指定されているサイズのヘッダ読み込みに失
                        敗したことを示します。
ERROR_INVALID_END_MARK  (0x8043)
                        不正な終了情報が書庫のエンドマークとして記録されて
                        いることを示します。
ERROR_INVOLVED_LZH      (0x8044)
                        ZIP 書庫など， 他の書庫に格納されている LZH 書庫で
                        あると UNLHA32.DLL が判断したことを示します。
ERROR_NO_END_MARK       (0x8045)
                        必要な終了情報が書庫のエンドマークとして記録されて
                        いないことを示します。
                        大昔の UNLHA.DLL (非 32) を含めて， 一部の圧縮エン
                        ジンでは必要なエンドマークが付加されていず，結果こ
                        のエラーを何度も拝むことになります。(^^;;
ERROR_HDR_INVALID_SIZE  (0x8046)
                        該当ヘッダのサイズとして不正な値がヘッダに記録され
                        ていることを示します。
ERROR_UNKNOWN_LEVEL     (0x8047)
                        UNLHA32.DLL で扱えないヘッダ形式であることを示しま
                        す。
ERROR_BROKEN_DATA       (0x8048)
                        CHECKARCHIVE_FULLCRC を指定してUnlhaCheckArchive()
                        によるチェックを行った場合に，格納ファイルが壊れて
                        いたことを示します。
                        通常，このエラーが返されることはありません。
ERROR_INVALID_PATH      (0x8049)
                        基準ディレクトリーやルートディレクトリーを越えたも
                        のなど危険性のあるパスが指定されたことを示します。
ERROR_TOO_BIG           (0x804A)
                        ファイルの大きさがファイルシステムで扱えるサイズを
                        超えていることを示します。UNLHA32.DLL での制限は以
                        下のとおり：

                                FAT                      : 2 GB 未満
                                FAT32 (Windows 9x)       : 2 GB 未満
                                FAT32 (Windows 2K 以降)  : 4 GB 未満
                                NTFS                     : なし

                        本来，FAT32 であれば， Win 9x 系であっても 4 GB ま
                        でのファイルを扱えますが， size_t (signed long) で
                        処理を行っているものが NT 系に比べて格段に多いと予
                        想されることから， Win 9x 系では 2 GB までとしてい
                        ます。
ERROR_EXECUTABLE_FILE   (0x804B)
                        "-jtz"  スイッチで抑制指定を行った拡張子をもつファ
                        イルの展開を行おうとしたことを示します。
ERROR_INVALID_VALUE     (0x804C)
                        API に渡したパラメータの整合性がとれていないことを
                        示します。現在の版では，API に渡されたバッファにつ
                        いて，当該バッファのサイズとして渡されたサイズの確
                        保が行われていない (とシステムが判断した) 場合と，
                        システムが  ERROR_INVALID_PARAMETER を返してきた場
                        合 (大抵は NULL ポインタ) に返されます。
ERROR_HDR_EXPLOIT       (0x804D)
                        バッファオーバフローやファイルの隠蔽など，脆弱性の
                        利用を意図していると疑われるヘッダが見つかったこと
                        を示します。
ERROR_HDR_NO_CRC        (0x804E)
                        拡張ヘッダが存在するにもかかわらず，記録されている
                        べきヘッダ CRC (共通ヘッダ) が存在しないことを示し
                        ます。
ERROR_HDR_NO_NAME       (0x804F)
                        h2 形式書庫について， 記録されているべきファイル名
                        ヘッダが存在しないことを示します。


-----------------------------------------------------------------------
%6. その他
-----------------------------------------------------------------------

  a : Unicode 対応化について

  　Ver 2.39 以降では，内部動作が Unicode ベース (ただし，部分的に ANSI 版
  API が使われています) のものへ変更され，さらに Ver 2.61 以降では Unicode
  アプリとなっています。これに伴って，当該コードページで表現できない文字を
  もつ名前のファイルについても扱えるようになっていますが，Windows XP/2K 等
  NT 系 OS 環境であっても，Ver 2.40 で追加された Unicode 版の API を使用し
  ない限り，それらのファイルを正常に扱うことはできません。従来の (ANSI 版)
  API を使用した場合は，ワイルドカードによる一括指定 ("*.*" または "*") を
  行った場合のみ，概ね正常 (意図したとおり) に扱えます。

  　従来の (ANSI 版) API を使用した場合，また，Win 9x 等 ANSI 系環境の場合
  には， WideCharToMultiByte() API を使用して Unicode→ANSI の変換が行われ
  ますが，当該コードページで表現できない文字については，以下のような変換が
  行われます。

        1 : 通常，UNLHA32.DLL は当該コードページで表現できない文字について
            '_' の文字へ変換を行います。ANSI 版 WIN32 API の暗黙変換とは異
            なる変換である点に注意が必要となります。
        2 : Windows NT 4.0 等， Windows 2K より前の NT 系 OS，及び Windows
            95 と Win32s では，WideCharToMultiByte() API の仕様 [*1] から，
            ANSI 版 WIN32 API の暗黙変換と同様の変換となります。例えば，日
            本語環境  (コードページ 932) において， L'(c)' ((c) は Unicode
            の U+00A9) の文字を扱った場合， Windows 2K であれば '_' へ変換
            されますが，Windows NT 4.0 では 'c' へ変換されます。Unicode で
            しか扱えないハートマーク (Unicode の U+2665)  のような文字につ
            いては，1 と同じく '_' の文字へ変換されます。
            --------------------------------------------------------------
            [*1]  '_' への変換は  WideCharToMultiByte() API に WC_NO_BEST_
                  FIT_CHARS フラグを指定することで行っていますが，このフラ
                  グは Windows 95 等では無効 (ERROR_INVALID_FLAGS エラーと
                  なる) となっています。一見 WC_COMPOSITECHECK |
                  WC_DEFAULTCHAR  といったようなフラグ指定で代替処理を行え
                  そうに思えますが， WC_DEFAULTCHAR は『例外時のみ有効』な
                  もので，無理矢理強引な組み合わせで合成が行われたアクサン
                  付き母音文字等であれば別ですが， L'(c)'  ((c) は Unicode
                  の U+00A9) の文字や  NTFS ファイルシステムが通常作成する
                  合成文字は，WC_DEFAULTCHAR  による例外の対象とはなりませ
                  ん (そもそも例外ではない)。

  　Unicode 版 API の追加される Ver 2.40 以降においては， インクルードヘッ
  ダファイル (UNLHA32.H) が変更され，Unlha() といった既存の API については，
  UNICODE マクロの定義により ANSI 版 (UnlhaA)， Unicode 版 (UnlhaW) の，ど
  ちらの定義ともなり得ます。 Unicode 版アプリの作成時において UNLHA32.H を
  使用する場合には注意してください。

  　これに対して， GetProcAddress() API によりアドレスを取得する場合には，
  変更の必要がありません。 "Unlha" は従来どおり ANSI 系 API の呼び出しとな
  ります。こちらの場合は，誤解を避けるために "UnlhaA" のような明示的な指定
  をしておいたほうが良いかもしれません。

  　Unicode 版 API で扱われる文字コードは全て UTF-16LE (リトルエンディアン
  の UTF-16) です。 BOM (Byte Order Mark) は認識しませんので，埋め込まない
  ようにしてください。バッファへの出力等の際にも埋め込みは行われません。

  b : メモリマップドファイルについて

  　Ver 1.99 以降では， ファイルの入出力にメモリマップドファイルを使用して
  います。 Windows 2K 以降の NT 系 OS 環境で，対象がローカルの固定ディスク
  の場合にメモリマップドファイルの有効化を図り，  有効化できなかった場合は
  ReadFile()，WriteFile() API を使用した通常の方法によるアクセスを行います
  が，入出力ルーチンが異なっていることから，エラーが発生した場合のログ出力
  等が従来と異なっている場合があることに注意して下さい。
  　Win 9x 系でもメモリマップドファイルの利用は可能なのですが， メモリー環
  境の貧弱であることが多いため，採用していません。

  　読込オープンの際にはファイルのサイズでマッピングを行っていますが，書込
  (を伴う) オープンの際には， 8MB 境界でのマッピングを行い，以降 (必要あれ
  ば) 8MB 毎にサイズを増加しながらマッピングし直しています。そのため，ディ
  スクの空き容量が少ない場合 (時には連続空き容量が少ない場合を含む) は，UN-
  LHA32.DLL  による空き容量チェックには通っていても， ディスク容量不足でエ
  ラーとなる場合があります。
  　これに伴い，MapViewOfFile() API で確保するビューも，8MB と，かなり小さ
  いサイズとなっていますが，あまり大きな速度低下は招いていないようです。

  　一旦 MapViewOfFile() API  で確保したビューについては，通常，システムに
  より適当なタイミングでフラッシュが行われることになるわけですが，書込オー
  プンの際は，基本的にファイルハンドル自体がクローズされるまで実際の書込が
  留保される傾向にあり，クローズ後も少量ずつの書込に留まります。そのため，
  巨大なファイルを扱った場合に，環境によっては実メモリーを使い切ってしまい
  大容量の連続スワップによるハングアップが起こっていました (何ら問題の起き
  ない環境が大多数を占めます)。

  　このような状況を回避するために，UNLHA32.DLL は 256MB 毎に FlushViewOf-
  File() API を使用して強制的にフラッシュを行っています。 フラッシュが行わ
  れる際には (大抵は 256MB の書込が発生することから)  一瞬固まったかのよう
  な状況に陥りますが，異常ではありませんので ご注意下さい。(最後に開いてい
  たビューなど)  256MB 境界に満たない端数の部分に関しては， 強制的なフラッ
  シュを行わずシステムに任せています。

  　Ver 2.63a 以降では，基本的に強制フラッシュを行わないようになっています
  ので，フラッシュを行わせたい場合は，設定ダイアログでフラッシュ指定項目を
  オンにしてください。64MB 毎に FlushViewOfFile() が実行されます。

  c : タイムスタンプの補正について

  　通常，UNLHA32.DLL はファイルシステムの仕様やシステムの制限等により正常
  に扱えない恐れのあるタイムスタンプが渡された場合には，正常に扱えるデータ
  へ補正するようになっています。補正については， NTFS とそれ以外でそれぞれ
  次のように処理されます。

        [FILETIME メンバーの存在する h2 形式書庫]
        NTFS    : Sep.14,1752 00:00:00〜Dec.31,2099 23:59:58
                  　上限については， Win 9x 系での DosDateTimeToFileTime()
                  等 DosDateTime を扱う API のバグ等を考慮してのものとなっ
                  ています。 Windows 2K 以降の NT 系 OS では 2399 年までと
                  なります。詳しくは後述の『参考』を参照。
                  下限については， Ver 2.58 以降では，英国での採用暦切り替
                  えを考慮して日付を連続して遡れる Sep.14,1752  までとなっ
                  ています。
        FAT     : Jan.1,1980 00:00:00〜Dec.31,2099 23:59:58
                  　上限については NTFS の場合と同じなので。以下，上限につ
                  いての説明は省略。
                  下限については，単純に FAT ファイルシステムでの ftime の
                  下限である Jan.1,1980 00:00:00 を使用。

        [FILETIME メンバーの存在しない h2 形式書庫]
        NTFS    : Jan.1,1970 00:00:00〜Dec.31,2099 23:59:58
                  　書庫の情報が time_t によっているので，下限は単純に
                  time_t の下限である Jan.1,1970 00:00:00 を使用。
        FAT     : Jan.1,1980 00:00:00〜Dec.31,2099 23:59:58
                  　下限は単純に FAT ファイルシステムでの ftime の下限であ
                  る Jan.1,1980 00:00:00 を使用。

        [h0/h1 形式書庫]
        NTFS/   : Jan.1,1980 00:00:00〜Dec.31,2099 23:59:58
        FAT       　書庫の情報が ftime によっているので， ファイルシステム
                  にかかわらず ftime での丸めとなっています。

  　さらに， UNLHA32.DLL は ftime 形式の整合性チェックと補正についても行い
  ます (Ver 1.55c 以降)。Feb.31,2003 26:13:02 といった不正なデータが渡され
  た場合，Feb.28,2003 23:13:02 という正常な値に補正した上で扱います。 元の
  データが単純な不正データであるのか，時間計算等の結果としての『Feb.28,
  2003 の 3 日後』『時間が経っての深夜 26 時 (午前 2 時) という意味の  26:
  13:02』であるのかは判断できないので， UNLHA32.DLL は単純な補正しか行いま
  せん。

  (参考)

  　UNLHA32.DLL の行うタイムスタンプの『丸め』については，下限はともかく，
  上限は Win 95 系での API のバグを考慮してのものとなっています。

  　Win 95 系では，今後はともかく現状では FAT ファイルシステムしか扱えませ
  ん。従って，ファイルのタイムスタンプの管理は，最終的には FAT/MS-DOS でお
  なじみの ftime…つまりは DosDateTime で行わざるを得ません。

  　しかし，Win 95 系においては，DosDateTimeToFileTime() 等の API が 2100/
  02/28 23:59:58 を超えると破綻します。

             [Win 98SE]
            ========================================================
              ftime : F05C0000 (time: 2100/02/28 00:00:00.000)
              →FILETIME: 022F9EF713598000 (2100/02/28 00:00:00.000)

              ftime : F0610000 (time: 2100/03/01 00:00:00.000)
              →FILETIME: 022FA089682D0000 (2100/03/02 00:00:00.000)

              ftime : FE210000 (time: 2107/12/31 00:00:00.000)
              →FILETIME: 019EB43019A6C000 (1970/11/25 17:31:44.000)
            ========================================================

  　この問題は，化け方はともかく Y2K 問題ならぬ 2100 年問題に他なりません。
  以前の版の Windows における 2000/02/29 問題への MS の解答は， 少なくとも
  この部分に関しては『4 年毎の通常の処理しか行わない』というもののようです。
  それだけなら良かったのですが，HISTORY.TXT にも記述のあるとおり，内部的に
  UNIX 系でおなじみの time_t を使用していることから，その限界を超えた 2107/
  12/31 00:00:00 の変換結果は，ほぼ DWORD でのオーバーフローを反映したもの
  となっています。 わずか 1 年ほどの期間での問題といえますが，詰めをちゃん
  とやってもらいたいところです。その前の段階で転けているわけですが…。(^^;;
  　なお，この DosDateTimeToFileTime() 等の問題は NT には存在しません。

  　それとは別に， Windows 95/NT 系双方に共通する問題として dir コマンド等
  の不具合があります。

             [NT 3.51 SP5]
            ========================================================
             00/01/01  00:00                      6 21000101.TXT
             00/02/28  00:00                      6 21000228.TXT
             01/01/01  09:00                      6 21000301.TXT
            ========================================================

             [Win 98SE]
            ==========================================================
             20991231 TXT             6  99-12-31  23:59 20991231.TXT
             21000101 TXT             6  99-01-01   0:00 21000101.TXT
             21000228 TXT             6  99-02-28   0:00 21000228.TXT
             21000301 TXT             6  99-02-29   0:00 21000301.TXT
            ==========================================================

  　このように NT には 2100 年問題が存在し，Win 系ではそもそも 2099 年を超
  えるデータが扱えません。 『枯れた部分 (要は古い)』だからこそ問題が出るの
  かもしれませんが，あまりにも基本的なコマンドであり『部分』でもあるので，
  非常に不安にさせるバグとなっています。

  　以上のようなシステムのバグから，UNLHA32.DLL においては，上限については
  上記の範囲での丸めを行うようになっていますが， NT 系では基本的に (コマン
  ド等での) 表示上の問題だけと思われることから，Ver 2.58  以降では Windows
  2K 以降の NT 系 OS の場合のみ 2399 年まで扱えるようになっています。

  　下限については『そもそもそんなタイムスタンプのファイルが， (まともな状
  況において) この先登場するはずがない』ということで，特に考慮していなかっ
  たのですが，Ver 2.58 以降では，英国での暦切り替えを考慮して， 連続して日
  付を遡ることが可能である Sep.14,1752 までとなっています。

  d : Windows 及び MS-DOS で扱えない文字について

  　Windows や MS-DOS 以外で作成された書庫の場合，"*2001/12/01 Data*" のよ
  うな使用できない文字を含んだ名前をもつ格納ファイルを含んでいることがあり
  ます。

  　UNLHA32.DLL は，このような使用できない文字については，次の規則による変
  換を行った上で処理を行います。(変換後の文字については『'』が付加されてい
  ますが，これは '-' (ハイフン) と '_' (アンダースコア) の区別をはっきりさ
  せるために付加しているもので，実際の変換結果には含まれません)

         文字 | 変換後 | 備考
        ------+--------+--------------------------------------------------
          /   |  '-'   | 　2001/11/01 のように日付として使われることが多い
              |        | ことから，"2001-11-01" と把握しやすいように変換
        ------+--------+--------------------------------------------------
         *, ? |  '_'   | 　lh0 形式の場合は '\' はディレクトリーセパレータ
         \    |        | を意味するので，変換しない
         空白 |        | 　空白については，' ' (0x20) 未満の 0x01〜0x1f ま
              |        | での一連の文字を指す

  従って，上記の "*2001/12/01 Data*" は "_2001-12-01 Data_" として扱われる
  ことから，UnlhaGetFileName() 等の API では後者が返ってくることになり，ま
  た  Unlha() 等でも『d work.lzh "_2001-12-01 Data_"』のように変換した名前
  を渡す必要があります。

  　なお， 一部のアプリに於いて Unlha() の 'L'・'V' 命令を使って格納ファイ
  ルの一覧取得が行われていることから，UNLHA32.DLL はこれらの命令に於いても
  変換後の名前を出力するようになっています。

  e : UnlhaOpenArchive() 等のハンドルについて

  　UnlhaOpenArchive などで返されるハンドルの指すグローバルメモリーは GMEM_
  MOVEABLE となっていますので， 構造体へのポインタとして利用する場合には，
  参照時にロックが必要となる場合があります。

=======================================================================
