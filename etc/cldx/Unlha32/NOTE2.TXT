=======================================================================
               UNLHA32.DLL Ver 2.67a API 補足説明ファイル
=======================================================================

                                               Ｍｉｃｃｏ (Sep.12,2010)


はじめに

　UNLHA32.DLL のドキュメント構成は以下のようになっています。

    API.TXT      : 基幹を成す Unlha() 系及び OpenArchive() 系 API の説明
    NOTE2.TXT    : API.TXT の補足説明
    COMMAND.TXT  : Unlha() に渡すコマンド文字列についての説明
    NOTE.TXT     : COMMAND.TXT の補足説明
    WINMES.TXT   : SetOwnerWindow() 系 API の説明
    ENUMAPI.TXT  : SetEnumMembersProc() 系 API の説明
    STRTABLE.TXT : ストリングテーブルと言語設定用 API についての説明
    HEADER.TXT   : LZH 書庫ヘッダ仕様の説明
    INFCOM.TXT   : Win32SFXM で使用される $ ファイルコマンドの説明
    QandA.TXT    : 過去にあった主な質問集
    HISTORY.TXT  : 修正履歴

　このドキュメントでは， API.TXT 等で説明されている各種 API の補足説明を行
います。要は NOTE.TXT の API 版です。とは言うものの， コマンド説明と違って
あまり追加して書くようなネタはないわけですが…。


　NOTE.TXT と同様に  Ver 1.51 より前の版との互換性等についての補足は一切行
われていませんし，以下同文…。

--------------------------------------------------------------------------
%0  概要
%1  1. UnlhaGetVersion
%2  2. UnlhaGetRunning
%3  3. UnlhaSetBackGroundMode
%4  4. Unlha
%5  5. UnlhaCheckArchive
%6  6. UnlhaConfigDialog
%7  7. UnlhaExtractMem
%8  8. UnlhaCompressMem
%9  9. UnlhaOpenArchive
--------------------------------------------------------------------------


%0  概要

　API.TXT の冒頭で記述されているとおり，『UNLHA32.DLL はスレッド・セーフで
はありません』し，API  の混在もできません。従って，UnlhaOpenArchive() して
書庫を扱っている最中に Unlha() で別の書庫を処理…なんてことはできません。


%1  1. UnlhaGetVersion

　API.TXT に記述されているとおり， リソース情報の下位 2 ワードを得たい場合
には UnlhaGetSubVersion() を使ってください。


%2  2. UnlhaGetRunning

　UNLHA32.DLL は各 API の実行前にこの API を使用して動作中かどうかのチェッ
クを行っています。が，UNLHA32.DLL が行うのは『TRUE の場合には API を実行し
ない』という単純な処理なので，その場にあった対応を行うためにも，アプリ側で
明示的にこの API でチェックしたほうがいいでしょう。


%3  3. UnlhaSetBackGroundMode

　少なくとも，現在の版ではこの API を使う意味はあまりないです。 が，ユーザ
がどの版の DLL を使っているかが確実に判断できる状況でない限り， 指定を行っ
ておいたほうがいいでしょう。


%4  4. Unlha

　この API を使用するには， LHA のコマンド仕様の理解が必須となります。…と
いうことは， 『UNLHA32.DLL を使用するには LHA のコマンドの理解が必須』とい
うことになります。

　COMMAND.TXT 等のドキュメントは参考でしかありません。ドキュメントを読んだ
り周りの識者に質問するだけではダメで， 理解するには LHA を使うなりして実際
にいろいろ実験して経験を積むしかないです。

        _hwnd       ここで指定されたウィンドウが親ウィンドウとなるのはいい
                    として，とにもかくにも EnableWindow(_hwnd, FALSE) され
                    ることを忘れないこと。この仕様も『過去のしがらみ』です。
                    DLL を呼び出している最中も，ばりばりにウィンドウを操作
                    できてしまうために，『展開を行っている最中に，格納ファ
                    イルを削除…しようとした結果として一般保護エラー』なん
                    てアプリが昔は乱立していたので…。
        _szOutput   オリジナルである LHA が DOS 用のコンソール・アプリだっ
                    たなごりで，ここで指定したバッファにログを吐き出す仕様
                    となっています。Unlha() の返却値だけではエラーの原因の
                    特定が困難なので，ログを記録するようにしておいたほうが
                    いいでしょう。原因を確実に特定できるわけではありません
                    が，ログがないよりははるかにマシです。
        _dwSize     当たり前ですが，_szOutput で指定するバッファについては，
                    ここで指定したサイズが確実に確保されていること!!  困っ
                    たことに，これが守られていないアプリが存在します…。

  　信じられないことですが， _dwSize に 513 などと指定しておきながら，_sz-
  Output に "" (たまたま空なのではなく，書き込み不可の文字列定数領域) など
  といったものを渡している例が多々見受けられます。上にも書いてありますが，
  _dwSize は _szOutput のサイズを指定しているわけですから， そこで指定した
  以上， _szOutput で指定するバッファは _dwSize で示されるサイズについての
  読み書きが保証されている必要があります。一般保護エラーになるのですが…と
  言う以前に，DLL や API の使用方法を勉強する必要があるでしょうね。 ログが
  必要ないのであれば，ちゃんと _szOutput に NULL  を渡すか _dwSize に 0 を
  渡すように!!


%5  5. UnlhaCheckArchive

　CHECKARCHIVE_FULLCRC  を指定しない限り正常に展開できるかどうかは判らない
わけですが，『LZH 書庫かどうか』チェックするのであれば  CHECKARCHIVE_RAPID
で普通は問題ないです。 冒頭に 128KB より大きいゴミが付加されている書庫とい
うのは，めったにお目にかかれませんから。相当凝ったインストーラ等だと可能性
がありますけど…。

　API.TXT でも言及しているように，CHECKARCHIVE_RECOVERY を付加しない限り，
壊れた書庫であっても単に FALSE を返してくる点に注意が必要です。

　なお，この API に通ったからといって， そのファイルに対して書庫操作が行え
るわけではありません。 この API は『そのファイルが書庫として読める』ことを
示しているに過ぎません。Lhasa のインストーラなどがそうですが，SFX には，書
庫をリソースとしてもっているものがあり，そのようなファイルに対して書庫操作
を行えば，当然ながらそれはすでに『不正な実行ファイル』でしかありませんし，
当然ながら実行してもエラー (下手をすれば一般保護エラー) となるだけです。


%6  6. UnlhaConfigDialog

　実際に表示されたダイアログを見るのが一番なんですが…。ダイアログの項目と
スイッチの関係は次のとおりです：

    ・基準ディレクトリー :
        ここが指定されていると，(Unlha のコマンドで) 基準ディレクトリー
        を指定しなかった場合に， カレントディレクトリーの代わりにここで
        指定されているものを基準ディレクトリーとして使用します。 初期値
        は "" ―つまり空の文字列―なので， カレントディレクトリーが基準
        となります。

    ・ディレクトリー構造を無視 :
        "-gj" スイッチ。チェックすると "-gj1"

    ・ディレクトリーの扱い :
        絶対パス : "-jf1"
        相対パス : "-jf0"

    ・不正パスチェック：
        Level 0 : "-jsp0"
        Level 1 : "-jsp1"
        Level 2 : "-jsp3"

    ・上書き時の確認 :
        常に上書き   : "-jyo1"
        確認する     : "-jyo0"
        上書きしない : "-c -jn"

    ・属性も展開 :
        "-a" スイッチ。チェックすると "-a1"

    ・ディレクトリー作成時の確認をしない :
        "-jyc" スイッチ。チェックすると "-jyc1"

    ・ディスクスペースの確認をする :
        "-f" スイッチ。チェックすると "-f1"

    ・合計でグラフ表示 :
        "-gn" スイッチ。チェックすると "-gn1"

    ・簡易ダイアログ :
        "-gn2" スイッチ。チェックすると "-gn2"

    ・バッファをフラッシュする :
        チェックすると，書き込みオープンされたファイルを閉じる際に Flush-
        FileBuffers()  されるようになります。 これをしないと監視ソフトと
        の相性 (というか，監視ソフト側の問題 ^^;) で不具合の出る場合があ
        ります (昔のウィルスバスター等)。

    ・旧式ログ出力 :
        チェックすると，ログ出力の改行が "\n" のみとなります。古いアプリ
        の場合にチェックを要するかもしれません。通常は "\r\n" です。


%7  7. UnlhaExtractMem

　Unlha() と同じ。指定されたバッファへ展開を行う点だけが異なっています。

        _lpBuffer      : ここで指定されたバッファに展開イメージが格納さ
                         れます。
        _dwSize        : 指定したサイズをちゃんと確保しておくこと。
        _lpTime        : 展開前にヘッダから情報を得れば済むわけですが，
                         更新日時を得ることができるようになっています。
        _lpwAttr       : 上記と同じ。属性を得ることができます。
        _lpdwWriteSize : 実際に展開されたサイズを得ることができます。


%8  8. UnlhaCompressMem

　Unlha() と同じ。 ただし，指定されたバッファのイメージを (ファイルである)
書庫に格納します。書庫のほうがあくまでも『ファイル』であることに注意。

        _lpBuffer      : 格納するデータのイメージ。
        _dwSize        : イメージのサイズ。
        _lpTime        : 格納対象がメモりイメージのため，タイムスタンプ
                         を直接指定することになります。 この API が実装
                         された時期を反映して，更新日時のみ。(^^;;
        _lpwAttr       : 上記と同じ。属性を指定します。
        _lpdwWriteSize : 圧縮後のサイズを得ることができます。


%9  9. UnlhaOpenArchive

　この API で作成されたハンドルは，必ず UnlhaCloseArchive() で破棄すること。
　通常の API の如くフラグ等で動作を指定しようとしたのは大失敗でした。 API.
TXT を見れば解るように，DWORD の 32 ビットでは，『何もなきが如く』の世界で
全く意味をなしていません。(T_T)  将来的には (まるで Unlha のようになってし
まう点は承知の上で) コマンド文字列で指定を行う『似て非なる』API を追加する
ことになると思われます…。というか，UnlhaExtractXX() だとか UnlhaCompress-
XX() といった API の追加を想定した場合，フラグではやっていけません。…とい
うことで，1.70 において UnlhaOpenArchive2() が追加されています。

　現在の仕様では， UnlhaOpenArchive() した時点で書庫が開かれ， 以後 Unlha-
CloseArchive() するまでは書庫が開きっぱなしである点に注意。 エラー (とアプ
リの対応) によっては書庫が『開かれたまま』となってしまうことが考えられます。
危険性が結構高いのですが， UnlhaFindNext() 等を含めて API の実行ごとに書庫
を閉じる仕様だと，監視ソフト等がたくさん動作している現在の多くの環境では，
下手をすると『死ぬほど動作が遅くなる』結果となるので，しかたなく現在の仕様
となっています。

　『死ぬほど』というのは大げさな表現ではありません。 10 万個ほどのファイル
が格納された 1GB 程度の書庫を扱った結果，監視ソフトによっては API の実行ご
とに『書庫全体をウィルスチェックする』こととなり，書庫を一通り読んで情報を
得ようとしただけで丸 2 日かかった…などという笑い話  (笑えないが ^^;) が実
際に多数報告された過去があります。ちなみに，監視ソフトを止めたらどうなった
かというと，30 秒程度で終わっていたりします。 ＞その報告

　なお，格納ファイルが 10 万もあると， NT 系では全部リストボックスに登録し
ようものなら，登録だけで 15 分ほどかかったりします。これは NT の仕様なので
どうしようもありません。  どころか，途中でハングするソフトの多いのが実情。
せめてハングしないようにしてほしいところです。

　そこまでいかなくても，UnlhaFindFirst()/〜FindNext() でのループに際しては，
読みながら登録するよりも，あらかじめすべての情報を得ておいた上で一気に登録
するほうが処理が速いです。その代わりメモリーはべらぼうに食いますが…。それ
でも，その書庫を作成した際に比べれば十分少ないはず。上記の書庫の場合，作成
時には 100MB 以上のメモリーを消費しています。

==========================================================================
