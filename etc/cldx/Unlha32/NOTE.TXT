=======================================================================
             UNLHA32.DLL Ver 2.67a  コマンド補足説明ファイル
=======================================================================

                                               Ｍｉｃｃｏ (Sep.12,2010)


はじめに

　UNLHA32.DLL のドキュメント構成は以下のようになっています。

    API.TXT      : 基幹を成す Unlha() 系及び OpenArchive() 系 API の説明
    NOTE2.TXT    : API.TXT の補足説明
    COMMAND.TXT  : Unlha() に渡すコマンド文字列についての説明
    NOTE.TXT     : COMMAND.TXT の補足説明
    WINMES.TXT   : SetOwnerWindow() 系 API の説明
    ENUMAPI.TXT  : SetEnumMembersProc() 系 API の説明
    STRTABLE.TXT : ストリングテーブルと言語設定用 API についての説明
    HEADER.TXT   : LZH 書庫ヘッダ仕様の説明
    INFCOM.TXT   : Win32SFXM で使用される $ ファイルコマンドの説明
    QandA.TXT    : 過去にあった主な質問集
    HISTORY.TXT  : 修正履歴

　このドキュメントでは，COMMAND.TXT で説明されている各種命令・スイッチの補
足説明を行います。多分に COMMAND.TXT と重複しています。 さらに，過去の版と
の互換性等についての補足は一切行われていません。そのため，このドキュメント
を読んで，さらに混乱する恐れもありますので，ご注意下さい。

　UNLHA32.DLL 独自の部分はともかく， 基本的にはオリジナルである LHA のあの
比較的簡単なドキュメントだけでも理解できる程度の内容について書かれています。
LHA (や UNLHA32.DLL を呼び出すコンソール的なツール) を使ってちょこちょこと
実験してみると理解が早いと思います。実際，LHA を自在に使いこなしている方々
は， このドキュメントで書かれているくらいのことは LHA のドキュメントだけで
理解されています。というか，理解していないことには比較的単純な圧縮・展開す
らままならないのが実情です。

　従って，補足説明といっても，COMMAND.TXT の中で注意が必要と思われる点を適
当に抜き出しているだけで，懇切丁寧に説明されているわけではありません。マー
カか何かでチェックしたものを抜き出したヒント集のようなものです。  苦労して
COMMAND.TXT 内を捜し回るよりもマシだと思いますので…。

　そうそう。 LHA  にはドキュメントで説明されていない隠し機能が存在しますが
(って，単にドキュメント化されていないだけなんですが)，それらについては UN-
LHA32.DLL では実装されていません。報告のあったものについて，一部実装されて
いるくらいです。

　説明順序については，基本的に COMMAND.TXT での順序に従っています。↓

--------------------------------------------------------------------------
%1   1. スイッチ文字
%2   2. ワイルドカード
%3   3. レスポンスファイル
%4   4. 'a' 命令と 'u' 命令
%5   5. 'a'・'u' 命令と 'f' 命令
%6   6. 'e' 命令と 'x' 命令
%7   7. 書庫内検索とリスト指定の関係。及び "-p" スイッチの存在理由
%8   8. 'm' 命令
%9   9. 's' 命令
%A  10. 'y' 命令
%B  11. "-a" スイッチ
%C  12. "-h" スイッチ
%D  13. "-i" スイッチ
%E  14. "-r" スイッチ
%F  15. "-d" スイッチと "-a2"
%G  16. "-u" スイッチ
%H  17. "-w" スイッチ
%I  18. "-jd" スイッチ
%J  19. "-jf" スイッチ
%K  20. "-ji" スイッチ
%L  21. "-jm" スイッチ
%M  22. "-jo" スイッチ
%N  23. "-jsb" スイッチ
%O  24. "-jse" スイッチと "-jss" スイッチ
%P  25. "-jsf" スイッチ
%Q  26. "-jso" スイッチ
%R  27. "-jst" スイッチ
%S  28. "-jx" スイッチ
%T  29. "-jy" スイッチ
%U  30. "-ga" スイッチ
%V  31. "-gj" スイッチ
%W  32. "-n" スイッチと "-gm" スイッチ
%X  33. "-gn" スイッチ
%Y  34. その他のスイッチ
%Z  35. 基準ディレクトリー
%a  36. 環境変数
%b  37. 作業ファイル名
%c  38. ヘッダ形式と圧縮メソッド
%d  39. ".lzh" の拡張子について (余談)
%e  40. UNLHA.DLL の登場経緯 (余談)
--------------------------------------------------------------------------


%1  1. スイッチ文字

　スイッチを表す文字としては '-' と '/' が使えることになっていますが，通常
は '-' を使用することになります。反対に言えば '-' で始まる名前をもつファイ
ルはスイッチとして誤認識されてしまうことになります。

　コマンドシェルの中には  '"' で括ることによりスイッチ文字等についても無効
とすることが可能なものもありますが， 残念ながら UNLHA32.DLL においてはそう
なっていません (今さら仕様変更なんて無理です… ^^;)。

　UNLHA32.DLL に '-' で始まる名前をもつファイルを渡したい場合は， 次の例の
ように "-gb" スイッチを使用してください。 …というか，対応アプリ側の処理と
しては『常に "-gb"  スイッチを付加する』ようにしておいたほうが楽かもしれま
せん。

        例 :   a archive.lzh -gb-test.txt
             "-test.txt" を書庫に格納。

　"-gb" スイッチは書庫を指定するのにも使えます。

        例 :   a -gb-work-.lzh *.txt
             "-work-.lzh" にテキストを格納。

　Ver 2.51 以降であれば， "--3" スイッチを使用することも可能です (LHA 互換
の "--2" スイッチではレスポンスファイル指定文字も無視されてしまうことから，
UNLHA32.DLL 独自である "--3" が追加されている)。他のツールで良く使われてい
る "--" スイッチに相当するもので，スイッチの指定位置に制限が生じるものの，
Ver 2.51 以降では，こちらを使用したほうが判りやすいと思います。

        例 :   a archive.lzh --3 -test.txt
             "-test.txt" を書庫に格納。

ただし，"--3" スイッチの使用には若干注意が必要で，LHA での "--2" (UNLHA32.
DLL も同じ) もそうですが，'-' の無効化を行った場合，'/' がスイッチ指定文字
として使用されます (LHA では MS-DOS のシステムで設定されているスイッチ指定
文字。通常は '/')。 従って，無効化を行う場合は，ディレクトリーセパレータと
して '\' を使用する必要があります。 他の DLL との絡みで '/' をセパレータと
して使用している場合には注意が必要です。

        例 :   a archive.lzh --3 c:/dir/test1.txt /dir/test2.txt
             "/dir/test2.txt" がスイッチ指定と見なされる。


%2  2. ワイルドカード

　COMMAND.TXT の説明を見れば解りますが，UNLHA32.DLL のワイルドカードの仕様
は『システムともオリジナルの LHA (のどの版) とも異なる独自仕様』です。"*."
と指定しても "test.txt" といった拡張子付きのファイルがマッチしてしまう (拡
張子なしのファイルのみを指定することが出来ない) プラットフォームが存在する
ため，そのような仕様となっています。


%3  3. レスポンスファイル

　基本的に，対応アプリ側の処理としては，渡すファイルの数に関係なくレスポン
スファイルを介してファイルのリストを渡すようにしておくのが得策です。平気で
50,000 といった数のファイルを D&D したりするのがユーザというものですから。
UNLHA32.DLL は 2,000 個強しかコマンドラインパラメータを受け付けませんので，
この際『レスポンスファイルは必須』とでも思ってください。

　なお，レスポンスファイルを使ったとしても，ランタイムやヒープ周りが破綻す
れば『それまで』です。それくらいの数になると，レスポンスファイル使用の有無
は関係なくなっているかもしれませんが…。リスト指定にマッチしたファイル数が
10 万個…という程度では破綻はしないようです (malloc されたハンドル数にする
と，さらに 2〜4 倍程度の勘定)…。


%4  4. 'a' 命令と 'u' 命令

　展開を含めて，基準ディレクトリーがどうとか各種スイッチがどうとかの難しい
話 (なのかしら？ ^^;) は後述します。

　'a' 命令と 'u' 命令の違いは簡単で， 'u' 命令がタイムスタンプの比較を行い
ファイルが新しい場合のみ格納を行うのに対して，'a' 命令ではタイムスタンプの
比較を一切行わず，常に格納を行います。つまり，たとえ既に書庫へ格納されてい
るもののほうが新しい場合でも，古いファイルが格納されるわけです。

　なお，余談ですが，'a' 命令については多少の注意が必要です。

　'u' 命令に "-c" スイッチを付加して "u -c1" と指定することにより， 'a' 命
令相当の動作を行わせることは可能ですが，反対に "a -c0" と指定して 'u' 命令
相当の動作を行わせることはできません。 なぜなら，オリジナルの LHA でもそう
ですが， 'a' 命令自身がもっている "-c1" の部分の処理が，すべてのコマンド・
スイッチ解釈が終わった後で行われる (行われるかのような結果が得られる) 仕様
となっているからです。要は UNLHA32.DLL がコマンド列の最後に "-c1" を自動的
に付加するようなもので，ユーザの指定した "-c" スイッチが無視されてしまうわ
けです。

　'a' 命令と 'u' 命令を使い分けるのであれば問題ないのですが，"-c" スイッチ
を利用して動作の切り替えを行う方法で実装を行う場合は， 必ず 'u' 命令を使う
ようにしてください。同じ内部フラグが扱われる "-u" スイッチ等も同様です。


%5  5. 'a'・'u' 命令と 'f' 命令

　'a' 命令等と 'f' 命令の違いは， 'f' 命令が書庫内のファイルの置換しか行わ
ないのに対して，'a' 命令等では書庫内に存在しないファイルについて追加格納が
行われる点です。

　例えば， "file1.txt" (のみ) が格納されている書庫に対して次のコマンドを実
行すると，

    a archive.lzh file1.txt file2.txt    : file2.txt が追加格納される
    f archive.lzh file1.txt file2.txt    : file2.txt は格納されない

という結果となります。

　なお，"-gf" スイッチを付加して 'u' 命令等を使った場合と， 'f' 命令を使用
した場合の結果には若干の違いがあるのですが，よほど特殊な指定をしない限りは
同じと見なしても問題ありません。(^^;;


%6  6. 'e' 命令と 'x' 命令

　巷での一般的な解釈は，『'e' 命令がパス情報を無視して指定したディレクト
リーへ展開を行うのに対して，'x' 命令はパス情報を利用してディレクトリーの再
構築を行いながら展開を行う』というものですが，その解釈では不十分で，これら
の命令の違いはそれだけではありません。

　'x' 命令は "e -x1m1" の省略形です。 従って，上書き確認やディレクトリー作
成の確認が抑制されることになります。アプリ側でこれらの確認の有無を明示的に
指定したい場合には，この点に注意しないと期待した動作とならないことになりま
す。アプリ側で確認の有無を指定する場合は，UNLHA32.DLL の省略値がどうであれ，
常にスイッチを付加するようにしておくのが得策です。

　『パス情報を有効にして展開』する目的で安易に 'x'  命令が使われ過ぎている
現状を考慮して，UNLHA32.DLL においては "-m" スイッチ等一部の動作を変更して
います。詳しくは COMMAND.TXT の各スイッチの項を参照してください。


%7  7. 書庫内検索とリスト指定の関係。及び "-p" スイッチの存在理由

　オリジナルの LHA でもそうですが， 書庫内検索におけるファイル指定リストの
扱いは特殊なものとなっています。コマンドラインで使用する分においては，便利
なこともあって (オリジナルで) そういった仕様となっていたわけですが，DLL を
使用する対応アプリとしては，ある意味その点が障害となってしまっています。

　パス名が付加されていないリスト指定を行った場合，書庫内検索においては，あ
たかも "-r1" スイッチが付加されたかのような検索結果が得られます。

　次のようなパス構成の書庫を想定します：

         (\) ←ルートの意味。絶対パスで格納されているのではない
          |  TEST.TXT
          |
          +-- TMP
               |  TEST2.TXT
               |
               +-- SUB1
                    |   TEST3.TXT
                    |
                    +-- SUB2
                             TEST.TXT

　ここで，『e archive.lzh c:\work\ *.txt』というようなコマンドを実行した場
合，ルート上に存在する "TEST.TXT" だけでなく，"-r1" スイッチが指定されてい
なくても， すべてのテキストファイルが "c:\work" 上に展開される結果となりま
す。

　このような仕様は，すべてのファイルを指定したい場合は便利なのですが，反対
に個別にファイルを指定したい場合はバグの素でしかありません。お気付きの方も
あるかと思いますが，上記の例でも別のパス上に存在する複数の "TEST.TXT" が同
じディレクトリー上に展開される結果となってしまいます (上書きが発生し，通常
どちらかは失われる)。

　つまりは，『e archive.lzh c:\work\ test.txt』と指定してルート上の "TEST.
TXT" のみを展開することはできないわけです。 この手の間違いを犯しているもの
が，たくさん存在します。

　『ルート上のファイルのみを指定できないのは困る』というわけで，あらかじめ
用意されているのが "-p" スイッチです。このスイッチの役目は，上記のような特
殊な処理を無効化することです。つまりは，
『e archive.lzh c:\work\ test.txt -p1』とすることで，無事ルート上の "TEST.
TXT"』のみを展開することが可能となるわけです。

　このような (ある意味) へんてこな仕様が適用されるのは，書庫内の格納ファイ
ルに対する検索時のみです。

　なお，COMMAND.TXT の "-p" スイッチの項で説明されているとおり，この仕様は
パスが付加されていないリスト指定の場合のみに適用されるのであって，例えば，
上記の例で『e archive.lzh c:\work\ tmp\*.txt』と指定した場合は，"-r1" スイッ
チが指定されていない限り，"TEST2.TXT" 以外の "SUB1" 配下に存在するテキスト
ファイルは展開されないことになります。

　『なんでそんな仕様なんだ〜!!』という声が聞こえてきそうですが (^^;;，当時
は "*.*"  などと指定 (というか省略値を利用して指定すらしない) してすべての
ファイルを展開することが多かったのでしょう。当時の利用状況を反映した仕様と
なっているわけで，事情は同じだったのか，海外起源の他形式アーカイバーツール
にも同様の仕様となっているものが意外と多く存在します。

　結果として， 対応アプリにおいては "-r" スイッチを伴わない場合は常に "-p"
スイッチを付加するようにするのが無難です。 反対に言えば，"-r" スイッチを伴
う場合や，"*.*" と指定してすべてのファイルを展開…といった場合などは，"-p"
スイッチを付加してはいけないわけです。


%8  8. 'm' 命令

　COMMAND.TXT でも説明されていますが，'m' 命令は，'u' 相当の処理を行った後
にリスト指定されたファイルを削除するコマンドです。ここで問題なのは，追加・
置換が行われたファイルのみが削除されるのではなく，書庫への格納が行われてい
ようがいまいが，『リスト指定にマッチしたファイルすべてが削除される』点です。

　この点をしっかり認識していないと，『気付いたときにはファイルが失われた後』
ということになります。


%9  9. 's' 命令

　まずは『その 1』。

　's' 命令は指定された既存の書庫を利用して自己解凍書庫を作成するのであって，
直接自己解凍書庫を作成するわけではありません。また，'u' 命令等を使用する際
に "archive.exe"  などと実行ファイルの拡張子を指定して自己解凍書庫を作成さ
せることもできません。 やってもエラーにはなりませんが，".exe" の拡張子をも
つ通常の書庫が作成されるだけです。

　この命令においては，いくら UNLHA32.DLL が Win32 用であったとしても，スイッ
チで指定しない限り 's' 命令のみで作成されるのは DosSFX です。 Win16 用であ
れば "-jw" を，Win32 用であれば "-gw" スイッチを付加する必要があります。

　作成される自己解凍書庫の名前は指定した書庫の拡張子を ".EXE" 等に変更した
ものとなります。別の名前で作成したい場合は，COMMAND.TXT で説明されているよ
うに "-gr" スイッチを使用して明示的に指定してください。

　UNLHA32.DLL Ver 1.96a 以降では，'a' 命令等，書庫操作を行う命令と "-jw"，
"-gw" スイッチを組み合わせることで，直接自己解凍書庫を作成することが可能と
なっています。

　『その 2』。

　Ver 1.54b 以降で作成された WinSFX32M，及び Ver 1.55 以降で作成された Win-
SFX32 は，それまでの版で作成されたものと異なりバイリンガル版となっています。
従って，設定ダイアログで直接指定したタイトル等以外は，すべて実行時の当該環
境の地域設定に従って表示が行われます。たとえ，英語版用に作成したものでも，
日本語環境では日本語表示となりますので注意してください。『英語環境でも日本
語表記をさせたい』という場合には，$ ファイルの $Language= を使用します。

　また，バイリンガル化に伴い，$ ファイルの仕様が変更されています。基本的に
日本語・英語版双方の専用命令となっている点に注意してください。


%A  10. 'y' 命令

　COMMAND.TXT で説明されているとおり，'y' 命令はヘッダの情報を変換するだけ
です。圧縮形式を変更することはできません。


%B  11. "-a" スイッチ

　COMMAND.TXT で説明されているように， "-a" スイッチの各モードの処理は次の
ようなものです。

        [格納時]
        -a0 : 隠し属性・システム属性のファイルは無視される。属性は，
              記録されないわけではなく，リードオンリーのファイルであ
              れば，しっかりリードオンリー属性が記録される。
        -a1 : すべてのファイルが属性を記録した上で格納される。
        -a2 : "-x1r2" スイッチと共に指定されている場合に限り，lhd メ
              ンバを作成してディレクトリー情報の格納を行う。

        [展開時]
        -a0 : 隠し属性・システム属性のファイルは無視される。属性が復
              元されることはなく，アーカイバー属性のみを有効にして展
              開が行われる。
        -a1 : すべてのファイルが属性を復元して展開される。
        -a2 : "-a1" と同じ。展開時は特に異なった処理となるわけではな
              い。

　ここで重要なのは，"-a0" が『単に属性の記録・復元を行わない』ものなのでは
なく，基本的に『隠し属性・システム属性のファイルを無視する』ためのものとなっ
ている点です。『純粋に属性の記録・復元の有無を指定』することができないこと
に注意が必要です。

　他のスイッチ等でもそうですが，LHA の仕様は，仕様としての美しさよりもツー
ルとしての実用本位に立ったものが多いと言えるでしょう。この辺りの事情は同じ
なのか，他のアーカイバーツールでも同じような特殊性がみられます。

　さて，"-a" スイッチの異端児であるところの "-a2" ですが， これについては，
"-r" スイッチへの見識を深めた後，"-d" スイッチの項で説明します。


%C  12. "-h" スイッチ

　COMMAND.TXT のとおりなのですが，自己解凍書庫に対して直接書庫操作を行う場
合や，直接自己解凍書庫を作成する場合には注意が必要です。

　自己解凍書庫は，展開機能をもっているとはいっても，書庫である以上余計な情
報 (要は展開ルーチン) は少ないに越したことはありません。そのため，種類の違
いにかかわらず，自己解凍書庫は自分に都合のよいヘッダ形式のみに対応していま
す。要は，その他の形式のヘッダは扱えないわけで，アプリ側で明示的に "-h" ス
イッチを付加したとしても，UNLHA32.DLL はその自己解凍書庫で扱えるヘッダ形式
を強制的に採用します。

　これに対して， オリジナルの LHA を含めて，かなりの格納エンジンにおいては，
ユーザが指定したヘッダ形式を使って書庫操作を行ってしまうため，結果として自
己解凍の行えない書庫が出来上がってしまいます。

　UNLHA32.DLL を利用するにしろ，その他のものを利用するにしろ，自己解凍書庫
に対しての書庫操作は避けたほうが無難です。

　なお，LZH 書庫では同一書庫内での複数形式ヘッダの混在が認められていますの
で，ヘッダ形式の決め打ちは行わないようにしてください。 UNLHA32.DLL の  API
を使わずに直接書庫を読み書きする際には注意が必要です。


%D  13. "-i" スイッチ

　このスイッチを使用する上で注意が必要なのはただ一つ。『スイッチを指定して
UNLHA32.DLL の動作を変更したところで，システム (ファイルシステム) が大文字・
小文字を同一視することに変わりはない』点です。 もちろん，NTFS 等において区
別するように設定されている場合は，この限りではありません。


%E  14. "-r" スイッチ

　お楽しみその 1 の "-r" スイッチです。が，動作自体は COMMAND.TXT のとおり
であって，それ以上の説明は，文章では，やりようがなかったりします。基準ディ
レクトリーとファイル指定の関係もそうですが， これは実際に LHA を使うなりし
て研究しない限り理解するのは不可能です。

　まずは "-r0" ですが， これは子ディレクトリー以下の再帰的な検索を行わない
ことを指定するわけで，特に説明の必要はないと思います。先に説明したとおり，
書庫内検索の特殊性から，一筋縄ではいかないわけですが…。

　次に "-r1" ですが，これはパス付加の有無に関係なく， 要は指定されたファイ
ルを再帰的に検索するわけです。パスが付加されていると解りづらいのですが，

        例 :  a archive -x -r1 C:\DIR\ *.txt
            DIR ディレクトリー以下のすべてのテキストファイルを格納

といった感じです。基準ディレクトリーからのパスの指示，若しくはパス情報を記
録するために，多くの場合でパスを付加した指定が行われているだけです。

　7 で説明した書庫内検索の仕様は，見方を変えれば『パスを付加せずにリストを
指定した場合は， 自動的に "-r1" が付加される』ということになります。

　最後に "-r2" ですが， このスイッチは，子ディレクトリー上のものを含めて，
指定されたディレクトリーに存在するすべてのファイルを処理するためのものです。
スイッチの仕様から解るように，本来『ディレクトリー』を指定してはじめて意味
をなすスイッチです。ファイルを指定してもエラーにはなりませんが，厳密には間
違った指定方法ということになります。

        例 :  a archive -x -r2 C:\WINDOWS
            WINDOWS ディレクトリー以下のファイルをすべて格納

　ちなみに，これは単なる『指定例』であって，実際にはいろいろ他のスイッチを
指定しないと ("-a" を筆頭に多数) ダメです，念のため。

　"-r1" と "-r2" の違いについては後述する "-d" スイッチの中の "-r2" の部分
も参考になるかもしれません。

　実際の対応アプリへの実装としては，普通は『指定されたディレクトリー配下の
ファイルをすべて格納』といったパターンが多いでしょうから，『そのような場合
には "-r2" スイッチを使用する』と覚えておけばいいでしょう。 やっていけない
のは， 他のアーカイバーツールからの類推で『"-r" を使えば大丈夫』と思い込む
ことです。

　参考ながら，ZIP や ARJ  といった他のアーカイバーツールにも "-r" スイッチ
が存在しますが， 多くは UNLHA32.DLL (LHA) のように "-r1"，"-r2" といったよ
うなモード指定は存在せず，しかもアーカイバーによって，その意味が "-r1" だっ
たり "-r2" だったりします。 どちらの仕様かちゃんと確認してから使わないとハ
マります。

　以下余談ですが，"-r2" スイッチを『文字列照合』として考えると，『指定され
た位置まで文字列が一致したもの』という解釈ができます。上の例で言えば，
"C:\WINDOWS" まで一致すればいいわけですから， 結果として子ディレクトリーの
ファイルについても処理が行われるわけです。

　ある意味， "-p" スイッチも文字列照合の方法を指定する…と考えられることか
ら，ARJ.EXE においては "-p"  スイッチの 1 モードといえる "-p1" が UNLHA32.
DLL の "-r2" と同じ動作を行うようになっています。 (それを移植したのが，UN-
LHA32.DLL の "-p2")


%F  15. "-d" スイッチと "-a2"

　お楽しみその 2 の "-d" スイッチです。異端児 "-a2" の説明もここで行います。

　まず最初に。"-d" スイッチは "-x1r2a2" の省略形です。従って，このスイッチ
の前後でそれらのスイッチを指定するのは支障を来すだけです。重複して指定を行っ
ているアプリが多すぎます，はっきり言って。このスイッチに限らず，仕様を把握
した上でスイッチを重複して指定 (どちらが無視されるか理解) しているのならい
いのですが，理解を伴わず無意味に重複指定しているだけのアプリが溢れています。

　さて，このスイッチを理解するには  LHA が登場した頃からの経緯を知る必要が
あります。というか，経緯を知ることで『なんでこんな仕様なの？』の謎が解けま
す。

　LHA が登場した頃は，ファイルをまとめて書庫に格納することはあっても，それ
は主に『ファイルを格納する』ためであって，ディレクトリー構造を含めてバック
アップする…といったような使用法はまだまだ少数派でした。今でも意外と少数派
ですけれど (バックアップ用のツールではない以上，これはある意味当然)。

　そのため，LHA 以前のものを含めて，当時の LZH 系の書庫には『ディレクトリー
の格納』といった処理に対する概念が (少なくとも表向きには) 整備されていませ
んでした。HEADER.TXT を参照すると解りますが，LHA でも展開時にディレクトリー
の再構築を行いはしますが，それは格納ファイルのヘッダに記録されているパス情
報を利用しているだけで，ディレクトリーが (ファイルと同じように) メンバーと
して格納されているわけではありません。

　従って，ディレクトリー自身の情報は復元されませんし，そもそもファイルの存
在しないディレクトリーは (ファイルしか格納しないことから) 格納すら行われな
いわけです (というか格納しようがない)。

　とは言うものの，当時から『これではいかん』ということで，表立って説明はさ
れていませんが，  かなり初期の段階で，  すでにディレクトリーを格納するため
の "lhd" メンバーの概念が整備され， 巷に出まわっている LHA Ver 2.13  でも，
ちゃんとメンバーの展開を行うようになっています。惜しむらくは，『C マガジン』
に収録された LHx Ver 2.02a や旧 NIFTYSERVE で公開されていた 2.01 の C ソー
スには (展開だけとはいえ) この辺りのコードが存在しなかったため，『未だに』
lhd  メンバーを扱えないものが存在します。 2 番目に巷に出まわっているであろ
う LHA Ver 2.55b 辺りでは，すでに正式対応している以上， 扱えないのは問題あ
るでしょうね，やっぱり。ちなみに，UNLHA.DLL も初期の頃は扱えませんでした。
(^^;)

　さて，lhd メンバーの展開しか行えなかった LHA も，Ver 2.14 になって，ちゃ
んと  lhd メンバーを作成してディレクトリーの格納が行えるようになりました。
ここで重要なのは，『当時は素直に "-x1r2a1" で lhd メンバーが作成されていた』
点です。当初は "-a2" などという異端児に登場願わなくても，普通に "-a1" を指
定することで期待どおりディレクトリーの格納が行われていたわけです。

　ここで威力を発揮するのが『互換性』という名の『過去のしがらみ』です。当時
出まわっていたものといえば LHA Ver 2.13 や Ver 2.11b です。 lhd メンバーの
展開しか行えない版であり，ドキュメントで言及されているわけでもなく，まして
や，そのメンバーを作成するツールは皆無だったわけです。 当然一般には lhd メ
ンバーの存在なぞ知りようもなく， 当時出まわりだした  LZH  関連のアプリでは
lhd をメンバーとして認識するものすら皆無と言っていい状況だったわけです (そ
りゃ，情報がなかったわけではありませんから，探せば見つけることができたわけ
ですが…)。

　LHA 系では，今も昔も普通に『ディレクトリー構造を保存しながらファイルを書
庫に格納』しようと思えば "-x1r2a1" を指定することになります。 結果として，
LHA Ver 2.14 以降を使う限り， 『ユーザが普通にパス付きの書庫を作成すると，
巷のアプリでまともに扱えない書庫が出来上がる』こととなってしまうわけです。
単純に lhd メンバーを無視するのではなく， エラーで処理を中止してしまうアプ
リが意外と多かったのです。

　スイッチの仕様や処理として正しい (望ましい) ものであったとしても，LHA ほ
どのメジャーなツールになると，既存のアプリで扱えないとなれば，それが許され
ません。 相当不具合報告と互換性に関する要望があったのでしょうか。哀れ 5 ヶ
月弱あとの LHA Ver 2.51  において『-x1r2a2』に変更されることとなってしまい
ました。                                ~~

　この Ver 2.51 で省略形である "-d" スイッチが登場したわけですが，これは省
略形といっても『"-a1" か  "-a2" か悩まずにすむ』ための意味合いが強かったの
かもしれません。

　長々ながと(^^;) 過去の経緯を説明してきましたが， これで『なぜ "-a2" なの
か』についてはご理解いただけたと思います。  言ってしまえば『互換性の関係上
"-a1" を採用することができなかった』だけです。

　なお， この経緯は，LHA  の各版のドキュメントや当時の大まかな状況を参考に
『私が勝手に推測したもの』であることを述べておきます。

　次に "-x1" ですが，これは説明するまでもないでしょう。 ディレクトリー構造
を考慮しない "-x0" では，ディレクトリーの情報を格納しようにもディレクトリー
自体が無視されてしまいますから。 あ，そうそう。"-a0" でない理由も "-x1" で
ある理由と似たようなものです。"-a0" ではリードオンリー以外の属性が扱われま
せんから，ディレクトリー属性が無視 (＝ディレクトリーが無視) されてしまいま
す。それだけです。

　最後に "-r2" ですが， これは上述の "-r" スイッチの項を見ると大まかな部分
が見えてくると思います。COMMAND.TXT を含めて，その辺りを参照するとお解りの
ように， "-r1"，"-r2" 共に子ディレクトリーを再帰的に検索してディレクトリー
構造を記録しながら格納を行いますが，"-r2" が指定されたディレクトリーに対し
て『丸ごと格納』を行うのに対して，"-r1" はあくまでも『ファイルの格納』を行
うだけです。

        例 :  a archive -x -r2 C:\WINDOWS
              a archive -x -r1 C:\WINDOWS\*.*
            他の必要なスイッチが付加されていない点は気にしないように

　この例は， 最終的には同じ結果が得られます。 が，指定の意味するところは全
く異なります。  絶対パスのままでは見かけがあまりにも似ているので，相対パス
にしてみましょう。

        例 :  a archive -x -r2 C:\ WINDOWS
              a archive -x -r1 C:\ WINDOWS\*.*

　相対パスにしてみると指定の違いがはっきりしてきます。"-r2" のほうでユーザ
が指定しているのはあくまでも『"WINDOWS" というディレクトリー』です。それに
対して  "-r1" のほうは『"*.*" つまりはすべてのファイル』です。  基準ディレ
クトリーの関係で "WINDOWS" というパスがくっついているに過ぎません。

　処理の結果にしたところで『たまたま "*.*"  だったから』同じになっていただ
けで，これが，

        例 :  a archive -x -r2 C:\ WINDOWS\*.txt
              a archive -x -r1 C:\ WINDOWS\*.txt

などと指定していたら， "-r1" のほうはユーザが期待したとおり Windows ディレ
クトリ以下のすべてのテキストファイルが格納されますが，"-r2" のほうで格納さ
れるのは Windows ディレクトリー上に存在する SETUP.TXT 等のテキストファイル
だけです。子ディレクトリーが検索されるわけでもなく，"-r2" の指定は全く意味
をなしていないことになります。 もちろん，"C:\WINDOWS\PATH.TXT\" なんてディ
レクトリーが存在すれば，そのディレクトリー以下については検索が行われますけ
れどね。

　"-r1" と "-r2" については，それぞれ『ファイルを扱うもの』『ディレクトリー
を扱うもの』と言えるわけです。そういうわけで，"-d" スイッチが "-r2" を採用
しているわけです。

　このことから，"-d" スイッチを指定する際に，

        例 :  a archive -d C:\WINDOWS
              a archive -d C:\WINDOWS\*.*

の 2 つのうち上段を採用しないといけないことが理解できると思います。COMMAND.
TXT でも説明しましたが，下段で指定しているのは『"*.*" にマッチするファイル』
であり，"C:\WINDOWS" が指定されたわけではありません。 結果，上段の指定では
"C:\WINDOWS" の lhd メンバーが作成され，下段の指定では作成されないわけです。

　まぁ，"-d" スイッチにしろ "-r" スイッチにしろ，LHA Ver 2.55b 辺りでも使っ
ていろいろと実験してみてください。実際に自分でやってみないことには絶対理解
できないと思いますので。 あ，もちろん『LHcm』等 UNLHA32.DLL を利用したコマ
ンドラインツールでも構いません。


%G  16. "-u" スイッチ

　特に説明の必要はないです。COMMAND.TXT で書いたように，'u' 命令がこのス
イッチを付加したような動作を基本としていますから，"-u1" を使うことはほとん
どないでしょうね。 命令の使い分けをせずに 'a' 命令だけで処理を行おうとする
際に登場願うくらいです。まぁ，他のアーカイバーツールと同じようなコードとし
たい場合には，そういった使い方がされることもあるでしょう。

　なお，'a' コマンドの仕様を考えれば判るように， 単に "-u1" を追加しただけ
では (大抵の方が) 期待するような動作はしてくれません，念のため。(^^;)


%H  17. "-w" スイッチ

　意外と，このスイッチに関する質問が多いんですよね。まぁ，特殊な部類に入る
ことは確かですけれど。

　一番凶悪なのは UNLHA32.DLL の "-w0" に関する記述が更新されず，ずっと『間
違った説明』がなされていたことでしょう。(爆)  "-w0" を明示的に指定すること
があまりなかった…というのが救いで，大きな問題とはなっていないわけですが。

　スイッチのモードを一覧にすると，

        -w0     : 書庫と同じディレクトリーを採用
        -w1     : システムが認識している作業ディレクトリーを採用
        -w<dir> : 明示的に <dir> を作業ディレクトリーとして指定

ということになります。

　LHA においては "-w0" が省略値なのですが， まぁ MS-DOS 環境でも多くの場合
は環境変数 TMP が設定されている関係上，自動的に "-w1" が内部指定されていた
わけですし，Win32 環境では『そもそもシステムが作業ディレクトリーを設定』し
た上で環境変数の設定も行われるわけなので， UNLHA32.DLL については "-w1" が
省略値となっています。

　あ，そうそう。 Win 9x においては，ユーザが明示的に環境変数 TEMP を設定し
ていない状況， つまりはシステムが自動的に "C:\WINDOWS\temp" を採用している
状況では，UNLHA32.DLL に限らず『作業ディレクトリー上にファイルやディレクト
リーの作成ができない』不具合の発生することがあります。特定シリーズのマシン
で極めて再現率が高い…といったように環境によるわけですが…。で，これが不思
議なことに，ユーザが明示的にどこか別の場所を環境変数 TEMP で指定してやると
解消する…なんてことが多いんですよね。一体どういう構造でこうなっているのや
ら…。(^^;;

　9821 系でよく見かけたので， システム周りで『C ドライブ決め打ち攻撃』でも
行っているものがあるんでしょうかねぇ？


%I  18. "-jd" スイッチ

　COMMAND.TXT に書いてあるように，スイッチをオフにする場合は "-jd-" とする
こと。"-jd0" としたのでは『空きがあれば』の意味になってしまいます。

　なお， 省略値の "-jd0" は一見『空きが 0 バイト以上あれば』ということで，
『空きがなくても展開が行われるのか？』と言われそうですが，実際には『展開し
た後に空きがどれだけ残るか？』というチェックが行われるわけで，  その時点で
0 バイトであるということは，『展開するとちょうど空きがなくなる』という意味
になるわけです。


%J  19. "-jf" スイッチ

　COMMAND.TXT の例を参照すれば一目瞭然だと思います。注意が必要なのは "-jf2"
で， これを指定して格納されたメンバーは UNLHA32.DLL 以外では展開できないこ
とになります。使用の際にはご注意を。暇があったら，まぁ，UNLHA.DLL くらいは
格納・展開が可能なようにしておきます。(^^;; もちろん，UNC はゲタを履いても
システム的に無理ですけどね。＞UNLHA.DLL


%K  20. "-ji" スイッチ

　COMMAND.TXT にもあるとおり， これで格納されたファイルは， はっきりいって
『その時点でしか有効ではない』ものです。格納した時点で "LONGNA~1.TXT" だっ
たからといって， それがそのままいつまでも有効だと思ったら大間違いです。 更
新・上書きが予想される使用法であれば，"-ji" スイッチの使用を考えるよりも短
い名前とロングファイル名の併用を改めて，最初から短いファイル名だけを使用す
るようにしたほうが得策です。


%L  21. "-jm" スイッチ

　COMMAND.TXT  に記述されているとおり， 他の多くのアーカイバーのような圧縮
速度や圧縮率の区分にはなっていません。 "-jm2"〜"-jm4" 辺りはスライド辞書の
サイズを指定していることになる関係上，他のアーカイバーのように速度や圧縮率
に差が現れてもおかしくないのですが，LHA の場合は，元から結構いろいろ工夫し
たアルゴリズムとなっている関係上，一番低い圧縮率 (に本来ならなりやすい ^^;)
となるであろう lh5 (lh4) においても割と高い圧縮率をはじき出しています。
さらに，LHA ではスライド辞書のサイズによる圧縮速度の差があまり表面化しませ
ん。それがさらに LHA Ver 2.6x や UNLHA32.DLL  ではハッシュ法を採用している
ために，一層速度の差が表面化しない結果に…。これには『スライド辞書のサイズ
変化が大きくない』というのも大きな理由となっているわけですが…。4K〜64K で
は通常の使用においては差の出ようがありません。  どこかのアーカイバー形式の
ように 4K〜4GB ほども開きがあれば， LZH 形式においても立派に速度の差が現れ
たことでしょう。

　まぁ，速度のほうはともかく， 圧縮率のほうは多少は "lh5" < "lh7" と上がっ
てくれるので， 全く無駄ということはないでしょう。 ちなみに，"-jm2"〜"-jm4"
の変更は，『それが意味をなすサイズ』のファイルに対して行わないことには指定
するだけ無駄…どころか書庫サイズの増大を招きます。


%M  22. "-jo" スイッチ

　COMMAND.TXT のとおりです。 一応 "-jo" と "-job" スイッチを組み合わせるこ
とで『A から B  の間に更新されたファイル』とかいった指定を行うことも可能で
すが，残念ながら

        例 : -jo20000101 -job20000102 -jo20010101 -job20010102
            『Jan.1,2000 と Jan.1,2001 に更新されたファイル』

などといった複数指定は行えません。

　要望はありますし，リストをもたせる程度の簡単な処理で対応できるわけなので
すが，それをやると『A かつ B』『A または B』といった指定ができないと意味が
ないし， それが可能な仕様だと殆どの方が混乱するのではないかと…。


%N  23. "-jsb" スイッチ

　COMMAND.TXT にあるように，このスイッチをオンにすると状況表示ダイアログの
『取消』ボタンが利かなくなります。

　表示が一切行われないバッチ等の処理ならまだしも，表示等を必要とする状況で
このスイッチが必要…ということになると，手抜きしているか構造がおかしいかの
どちらかです。  『取消』ボタンが使えないのを承知の上で使用する分には何も問
題ないです。


%O  24. "-jse" スイッチと "-jss" スイッチ

　まず，おおざっぱに言えば『展開時に影響する』のが "-jse" スイッチで『格納
時に影響する』のが "-jss" スイッチです。両方を一覧すれば

        -jse1 : 通常ならスキップされるだけの『展開時の共有エラー』を
                エラーとして処理中断するようにする
        -jss1 : 通常『格納時の共有エラー』で処理中断されるところを，
                単にスキップするだけにする

といった感じです。

　『共有エラーなら共有エラーとして，展開できなかった事実をエラーとして返し
たい』といった場合に "-jse" スイッチを使うことになります。通常なら，空きが
ない場合などと同様に単純にスキップされます。

　反対に『そのファイルが共有エラーとなることは最初から判っている』場合に使
うのが "-jss" スイッチです。例えば，『C:\WINDOWS』以下を丸ごと格納する場合
などは，当然ながらスワップファイル等は共有エラーとなるわけですが，Win9x 辺
りであれば，いざとなれば別段スワップファイルをいちいち格納しなくても構わな
いわけです。(笑)  そういった『単に格納を行わないだけで解決できる』場合に使
用するのがこのスイッチです。


%P  25. "-jsf" スイッチ

　通常，UNLHA32.DLL は NTFS や UNIX 等他のプラットフォームが起源の『Jun.27,
1967』といった更新日時のファイルを， それを表現できない FAT 辺りに展開しよ
うとした場合などには， それを正常に扱える (この場合なら) Jan.1,1980 に補正
します。

　が，『扱えないなら扱えないで，それをちゃんと知りたい』という場合も当然な
がらあるわけで， そういう場合に使うのがこのスイッチです。 現在の仕様では，
『知ることができた』==『エラーで処理中断』ですけどね，…他の多くのスイッチ
を含めて…。(^^;;  一番仕様変更を伴わずに改善するとすれば，EnumMembersProc
() のコールバック関数を特定コードで呼び出す方法なのでしょうけど， それでも
かなりのコード変更を伴うので，実装予定は全くないわけですが…。

　実際に普段どういうふうに補正されているかについては，COMMAND.TXT を参照。


%Q  26. "-jso" スイッチ

　COMMAND.TXT のとおりですが，このスイッチについては対応アプリは何も考えず
に "-jso1"  を指定しておくこと!!!!  要求が多過ぎて屈伏してしまいましたが，
『他人の書き込みを許可したままファイルを開く』なんていう現在の省略値の仕様
は問題外です。


%R  27. "-jst" スイッチ

　現在の版では，普通に書庫を作成すれば FILETIME 構造体ヘッダが作成されるわ
けですが，この拡張ヘッダは結構馬鹿にならないサイズ (普通は 27 バイト) だっ
たりします。小さなファイルを大量に格納する場合などは，しゃれにならないサイ
ズ増大を伴う結果となるので，このような場合はスイッチを使う意味があるかもし
れません。 当然ながら ftime レベルの更新時間以外の情報がすべて失われるわけ
ですが…。

　格納ファイルの圧縮率が高く非常に小さなサイズとなっている場合には，書庫自
体を再度圧縮することで，多少は縮小が可能かもしれません。 ＞FILETIME 構造体
ヘッダ付きの書庫


%S  28. "-jx" スイッチ

　COMMAND.TXT でも説明されていますが， このスイッチのための  "-p"  や "-r"
スイッチなどというものが存在しない関係上，"-jx" スイッチでディレクトリーを
丸ごと指定したい場合には，

              例：  e archive C:\*.* -jxC:\TMP\
                  C:\TMP ディレクトリー以下のすべてのファイルを除外

といったように '\' の文字を付加して指定する必要があります。 要は文字列照合
的指定になるわけです。"-p2" ("-r2") スイッチとはまた違った指定方法なので注
意。


%T  29. "-jy" スイッチ

　"-jyn" スイッチだけは初期値が "-jyn1" です。"-jyn0" を指定すると，上書き
確認等で『上書きしない』を選択した場合に，ファイル名を要求してくるようにな
ります。


%U  30. "-ga" スイッチ

　ごめん。今さら変更できないのでそのままにしてありますが，LHA 等の動作は
"-ga2" 相当です。つまりスイッチが指定されていない "-a0" 状態では，リードオ
ンリー属性のファイルは上書き確認することなく，単純に展開がスキップされます。


%V  31. "-gj" スイッチ

　このスイッチは 'x' 命令にしか作用しません。


%W  32. "-n" スイッチと "-gm" スイッチ

　"-n" スイッチは状況表示ダイアログを抑止するだけです。 エラーメッセージ等
を抑止するには別途 "-gm" スイッチを指定してください。 COMMAND.TXT に記述さ
れているとおり，"-gm1" を指定すると確認メッセージも省略され，すべて 'Y' が
選択されたものとして処理されます。

　多くの場合は自動実行を目的として "-n" が使用されますが，まじめに自動実行
を制御するのであれば，"-n" と "-gm" スイッチの指定だけでは不十分です。少し
考えれば判るように，"-n" や "-gm" によるメッセージやエラーの処理が (想定状
況において) 望ましいものとは限りませんし，自動実行であるがゆえに，各種設定
を明確に指定した上で処理を行う必要があるはずです。最終的には最低でも 15 種
くらいの設定系スイッチが必要となるでしょう。


%X  33. "-gn" スイッチ

　COMMAND.TXT に書かれているとおり，このスイッチを指定すると必然的に書庫が
二度読みされることになります。従って，このスイッチを指定して処理が遅くなる
のは『当たり前』です。


%Y  34. その他のスイッチ

　スイッチをいちいち切り分けていたのでは VZ のタグがいくらあっても足りない
ので，以降はまとめて思いついたものをつらつらと…。(^^;;

    a. "-jc" スイッチ

    　このスイッチは『破損した当該ヘッダを無視して，そこから新たなヘッダを
    検索する』ことで処理の継続を行うものです。破損箇所の格納ファイルを得る
    ことはできません。

    b. "-jr" スイッチ

    　『編集用』と銘打っていますが，通常は (アプリの) 作業用ディレクトリー
    にディレクトリー付きで解凍を行えば特に何も考えずに再格納が可能であり，
    別に難しいこのスイッチを使用する必要はありません。

    　このスイッチの存在意義は，『格納時においてパス情報が自由に設定可能』
    である点です。

    　COMMAND.TXT では実際に更新の例が載っていますが，このスイッチは指定さ
    れた基準ディレクトリーとファイルリストの解釈法の変更を指定するものであ
    り，命令自体の動作を変更するわけではないので，書庫の新規作成等の場合に
    も使用することが可能です。

    　が，特殊な命令であることに違いはないので， "-r" スイッチ等他のスイッ
    チとの併用やワイルドカードによる一括指定は行えません。解釈結果を推測す
    ることで使えなくもないですが，そんなことに時間を割くくらいなら使わない
    ほうが得策です。(^^;) ただし，次のような複数指定は行えるようです。作者
    は意図していないので正常に動作するかどうかは分かりませんが…。現在，拙
    作の LHMelt (Ver 1.17 以降) が実験台となってます。

          例 : u -jr arc C:\TXT\ SUB1\TEST1.TXT C:\EXE\ SUB2\TEST2.EXE
             この例では，C:\TXT\TEST1.TXT と C:\EXE\TEST2.EXE というファ
             イルを扱っていることになる。

    c. f 命令と "-jtc" スイッチ

    　'f' 命令と，('u' 命令での) "-jtc" スイッチは，基準が異なるだけで，実
    は似たような処理を行うものとなっています。共に書庫の更新を行うものです
    が，

        f       : 格納ファイルが基準。書庫内に存在しないファイルは，指定し
                  たとしても格納されない。
        u -jtc  : 指定ファイルが基準。指定されていない (指定にマッチしない)
                  ファイルが書庫内に存在した場合は削除される。

    といった感じになります。

    d. "-o" スイッチ

    　lh1 等，圧縮メソッドの指定を目的として "-o" スイッチが使われている例
    を良く見かけますが， "-o" スイッチは旧形式の書庫を作成するためのもので
    あって，圧縮メソッドだけが変更されるのではありません。書庫形式等の変更
    も伴いますし，(特に Ver 2.40 以降で顕著ですが) 拡張ヘッダ等， 格納内容
    も変更されます。LHA や LHarc での使用を前提としないのであれば，"-o" ス
    イッチは使用すべきではありません。


%Z  35. 基準ディレクトリー

　COMMAND.TXT 以上の説明は必要ないと思いますが (というか説明のしようがない)，
要は LHA を例にすれば，

        例 :  LHA a c:\tmp\archive.lzh C:\DIR\ SUBDIR\*.*

というのは，

              c:
              cd \dir
              LHA a c:\tmp\archive.lzh SUBDIR\*.*

という一連の動作を行ったのと同じです。

　なお，COMMAND.TXT の例にあった

     例：  e emelt017.exe c:\windows\system\ *.dll "c:\Program Files\" *.*
       DLL のみウィンドウズ・ディレクトリーに展開し，残りは
       c:\Program files に展開する

は，先頭からコマンド解釈が行われる関係上，『この順番だから意味がある』指定
です。間違っても

     例：  e emelt017.exe "c:\Program Files\" *.* c:\windows\system\ *.dll

なんて順番で指定しないように。(笑)


%a  36. 環境変数

    a. TZ

    　UNLHA32.DLL は Win32s 環境の場合のみ環境変数 TZ を明示的に読み込んで
    使用し，他の環境の場合は，当該環境の設定値 (システムが認識している情報)
    に従います。

    　Windows XP 環境等では TZ の設定を必要としない場合が多いのですが，MS-
    DOS の疑似環境としても機能していることが影響しているのか，コマンドプロ
    ンプト上の場合は，この TZ が設定されていないと (大抵は) タイムスタンプ
    がずれてしまいます。さらに，Windows 3.1 用など 16 ビット版のプログラム
    の多くが，この TZ の設定を必要とします。

    　従って，必ず TZ の設定を行うようにしてください。思わぬところでタイム
    スタンプのずれが発生します。

    　設定は，COMMAND.TXT 等で記述しているように，日本標準時での使用であれ
    ば：

          set TZ=JST-9

    となります。 たまに『数字は 2 桁』と決め打ちしているソフトが存在するよ
    うなので，"JST-09" としておいたほうが良いかもしれません。

    　多プラットフォームをよく利用される方であれば "-9" と負数になっている
    点が奇異に感じられるかもしれませんが，Win 環境では『UTC へ変換するため
    の数値 (x = UTC - JST)』を指定する仕様なので -9 となります。間違っても
    9 (+9) を指定しないようにしてください。


%b  37. 作業ファイル名

　命名規則については COMMAND.TXT のとおりで， LHTx.TMP (x は 1〜4 文字の不
特定の文字列) という名前の作業ファイル (実体は通常の書庫) が作成されます。
ここでは書庫操作の際に実際にどういった作業ファイルが作成されているかについ
て説明します。

　まず，Ver 1.94 以降では， 新規書庫が作成される場合には作業ファイルを介さ
ず，直接目的の書庫を作成します。それより前の版と大きく処理の異なっている点
に注意して下さい。

　次に，書庫の更新等の場合は以下のとおりです：

    I  :オリジナルの書庫を LHT1.TMP に変名します。
    II :処理結果を出力するために LHT2.TMP を作業ディレクトリー上に新
        規作成。
    III:LHT1.TMP (変名されたオリジナル書庫) を読みながら，更新・追加
        されるメンバーがあれば， LHT2.TMP に圧縮の上追加格納し，そう
        でなければ単純にメンバーを LHT2.TMP にコピー。
    IV :オリジナル書庫と作業ディレクトリーが同じドライブ上に存在して
        いず，さらに "-jsa1" が指定されていない場合は，ここで
        LHT1.TMP (オリジナル書庫) を削除。
    V  :LHT2.TMP (処理の結果作成された書庫) をオリジナル書庫の名前で
        コピー (又は変名)。
    VI :V でコピーが行われ，処理が正常終了した場合は LHT2.TMP を削除。
    VII:IV で削除されていない場合は，ここで LHT1.TMP を削除。

　このことから解るように，『作業ディレクトリー (のドライブ) == 書庫のある
ディレクトリー (のドライブ)』である場合には， オリジナル書庫と作成される作
業書庫の 2 つの書庫を合わせたサイズの空きが必要ということになります。 何ら
かの理由で書き戻しの際の変名が行えなかった場合には，UNLHA32.DLL はコピーを
試みますから， その場合には 2 つの作業書庫と書き戻されるオリジナル書庫…と
3 つ分の空きが必要ということになります。

　UNLHA32.DLL は，"-jsa1" が指定されていない場合でも，書き戻しが変名で行わ
れる場合など，処理時間や空き容量に大きく影響しない場合は，なるべく処理の最
後で LHT1.TMP (変名されたオリジナル書庫) を削除します。

　なお，ここでの LHT1.TMP や LHT2.TMP といった名前は，あくまでも一例ですの
で注意して下さい。


%c  38. ヘッダ形式と圧縮メソッド

　COMMAND.TXT がすべて。歴史的背景については，COMMAND.TXT に記述されていま
すし，ヘッダ仕様については HEADER.TXT を見れば一目瞭然です。

　圧縮メソッドについては概要が COMMAND.TXT に記述されていますが， 詳細につ
いては実際に LHA  等のソースを見ないとダメでしょうね。LHA のソースは実際問
題として入手が難しいので，一般的には LHA for UNIX 辺りを参照することになる
と思います。

　文章で説明されたものとなると…『C マガジン』の  '91.1 等を手に入れるしか
ないような…。 今にして思えば，12 月発売の雑誌に 11 月下旬の段階のソースが
収録されたわけだから，結構ぎりぎりのものを頑張って入れたことに…。


%d  39. ".lzh" の拡張子について (余談)

　UNLHA32.DLL が作成する LZH 書庫の拡張子は ".lzh" となっていますが， 昨今
の比較的多くのアーカイバー系ソフトと異なり，UNLHA32.DLL やオリジナルの LHA
のソフト名である "LHA" の名前が拡張子としては採用されていません。 最近のソ
フトしか知らない世代の方には謎となっているらしくて，時々，この手の質問メー
ルが飛んできます。

　今を去ること 20 年弱前 (80 年代の終わり) の海外では， UNIX 系の compress
という圧縮ツールを参考に作成された SEA 社の ARC や， PKWARE 社が作成した高
速互換アーカイバー PKARC が， パソコン (MS-DOS) 用ソフトとして広く使われて
いました。 アーカイバー系のソフトに "ARC" の名前が多いのは，この辺りのソフ
トの存在も一つの起源となっています。

　『圧縮』は，通信にかかるコスト削減には欠かせない技術の一つなので，その頃
には，日本でもアーカイバーに関する話題が盛り上がりを見せてきます (今でこそ，
ファイルのサイズをあまり気にすることなくダウンロードできたりしますが，昔は
扱うファイルの大小が， そのまま月に支払う通信料金の 1 万円と 10 万円の差と
いったような大きな違いとなって現れたのです)。

　そんな中で登場したのが，三木氏による LArc (88 年) です。このアーカイバー
は，奥村氏による LZSS が土台となっているのですが，LZSS の名前は，LZ77 のア
ルゴリズムの一つである LZSS 法からきていて，それが，そのまま LArc が作成す
る書庫の拡張子 (".lzs") にもなっています (MS-DOS では拡張子が 3 文字まで)。

　LArc が少しずつ国内で普及していく中， 奥村氏が，さらなる圧縮率の向上を目
指して LZARI というプログラムを作成します。 このプログラムは名前のとおり，
先の LZSS 法と (適応型) 算術符号を組み合わせたものなのですが，当時は算術符
号 (のバリエーション) についての， 現在の rc (RangeCoder) 法のような優れた
アルゴリズムが存在しなかったため，圧縮率は良いものの時間がかなり掛かってし
まうという欠点がありました (後には，算術符号に関する特許問題も浮上してきま
す)。

　ここで登場するのが吉崎氏が作成した LZHUF です。これは LZARI の算術符号の
部分をハフマン法 (適応型ハフマン) に置き換えたもので，それをアーカイバーソ
フトとして完成させたものが LHarc (89 年) です。 LHarc の作成する書庫の拡張
子が ".lzh" なのですが，これは LZHUF からきています。 LHarc はアーカイバー
の世界に大きな影響を与えたソフトで，ZIP 書庫のオリジナルと言える PKZIP.EXE/
PKUNZIP.EXE， ARJ 書庫の ARJ.EXE といった当時の (MS-DOS 系) メジャーなアー
カイバーは，みんな，この LHarc の影響を受けています。

　LHA (91 年) は， 名前は違えども実質 LHarc Ver 2.x となるソフトです。名前
が異なるのは， ARC を作成した SEA 社の『ARC の名前を使用しないで欲しい』と
いう意向によるものです。今なら訴訟でも起こされていそうですね。それはともか
く，"ARC" の文字を使えなくなったことから，当初は "LH" というソフト名を使用
していました。が，この "lh" というプログラム名が MS-DOS 5.0 で追加されたコ
マンド名と同じだったのです。そのため，テスト開発/技術解説用途の C 言語のみ
を使用して作成されたものについては "LHx"，公開に向けてのアセンブラを使った
正式版相当のものを "LHa"，とソフト名が変更されました。なので，"LHa" の 'a'
は "ARC" の 'a' というよりも，アセンブラ (assembler) の 'a' という意味合い
が強いものだったりします ('x' は， 戦闘機等でおなじみの『開発/実験機を表す
'X'』からきているのでしょうね，やっぱり…って，考え過ぎかしら？)。  その後
Ver 2.11 で "LHA" ('a' が大文字) の表記に改められています。

　上で書いたように，LHA が実質 LHarc Ver 2.x であることから， 作成される書
庫の拡張子も LHarc の ".lzh" が受け継がれているのです。

　ちなみに，後継のソフトであることから，LHA は LHarc 互換の書庫の作成/展開
が行え， LHarc で行えた (LArc による) LZS 書庫の展開も同様に可能となってい
ます。UNLHA32.DLL は，言わば LHA の移植ソフトなので， その辺りの仕様も受け
継いでいます。


%e  40. UNLHA.DLL の登場経緯 (余談)

　『統合アーカイバプロジェクト』の成り立ち…というか，『UNLHA(32).DLL が，
どのように登場したのか？』という質問も，たまに受けますので，こちらについて
も余談ついでに書いておきます。(笑)

　LHA が登場してから 2 年後の 93 年頃。世の中は MS-DOS から Windows へと移
り変わる過渡期にあって， 当時は Windows 3.1 が主流となっていました。 NT 系
OS も登場していましたが，一般ユーザが使う OS は  Windows 3.1 や 3.0A…どこ
ろか，MS-DOS ユーザも多かったのです (Windows は別途購入が必要でした)。

　この頃，Windows 用の国産アーカイバーとしては，nonki 氏による LHfe などが
登場していて，それらのソフトは，大概が kom 氏の LHA.DLL を使用していました。
LHA.DLL は (UNLHA32.DLL もそうですが) 極めて DOS 的な仕様をもつ DLL でした
が，当時は LHA の全盛時で， また，プログラムを作成しようとするような者であ
れば，大抵が LHA にも精通しており， かなり手軽に書庫操作のプログラム作成が
行えたことから，広く普及したものです (実質，これをもっていないと，こと LZH
書庫を扱う限りにおいては，Windows 用のアーカイバーは使えませんでした)。

　LZH 書庫操作用のツールとしては， フリーソフトである LHA.DLL が登場してい
て誰でも使える環境となっていましたが， 海外で主流であった ZIP 書庫用のツー
ルは MS-DOS 時代と同じくシェアウェアが殆どで， 誰もが自由に使える DLL のよ
うなものは存在していませんでした (当時 Info-zip の DLL 版は発展途上)。

　一方，既に登場していた LHA.DLL にも，システム的な制限と DLL 自身の仕様と
が絡んで，『展開 (書庫操作) 中にはシステムを含む他の操作が一切行えない』
『操作を行えるようにすることは可能でも，所要時間が 10 倍以上となってしまう』
『DLL のバグと環境が絡み書庫の情報が正常に取得できたり出来なかったりする』
等の問題が発生し， (特に一般ユーザにとっては) 決して使い易いと言えるもので
はありませんでした。

　93 年秋も終わりに近づいたある日， 旧 NIFTYSERVE の FWINDEV (Windows 開発
者フォーラム。 β版ソフトに関しての話題も扱っていました) にて，LHfe のバグ
報告のついでに『unzip (Info-zip) のソースから zip.dll って作れないのかな？』
と召還呪文を唱えてみたところ，『unzip のソースが転がっているなら作ってもい
いですよ』と shoda T. 氏を召還することが出来たのです。(笑)  その後， nonki
氏が ish.dll を作成してくださることになり， 言い出しっぺの私が何もしないの
では法則に反する…ということで，『とりあえず LZH  書庫は登場している。なら
登場していない ARJ 書庫用をば…』と  (メールで秘密裏に宣言した上で) unarj.
dll の作成に取りかかった…というのが，最初期の大まかな経緯です。

　今にして思えば，Windows プログラミングの知識が (ほぼ) ゼロの状態で，完全
技術解説用プログラムである，『指定された書庫をカレントディレクトリーに展開
するだけ』の UNARJ.EXE から LHA.DLL  と同様のインタフェースを備えた UNARJ.
DLL の作成に取りかかったのは，無謀以外の何でもないですね。(笑)  それでも
『一文字表示するのにも文字の画像 (ドット) パターンを用意して，ポートを叩い
て…』という処理をマシン語で行う必要のあった過去の経験に比べれば，API が用
意された Windows プログラミングの世界は天国に思えましたけど…(当然ながら，
それはそれで別の大いなる苦労が登場してくるわけですが)。 また，フォーラムを
通じて本職プログラマを召還できてしまう…といった辺りは，パソコン通信の利点
でもあり，平和な古き良き時代だった…ということなのでしょう。何しろ，一般人
にとっては，各種ソフトの作者の方々なんて雲の上の存在でしたから (今がどうか
と言うと，やっぱり雲の上の方々です。そんなものです)。

　さて，UNARJ.DLL の作成に取り掛かったものの，日頃からこぼしていた懸案事項
(愚痴) の一方は LHA.DLL であり，それらは解決に至っていませんでした。が，と
りあえずは UNARJ.DLL を軌道に乗せる必要があり，結局 UNLHA.DLL が登場するの
は 1 年以上後の 95 年となるのです。95 年初頭といえば，Windows 95 のα版
(FE 版) が開発者向けに配付された頃であり，幸運にも，そのα版を開発者でない
にも拘わらず使用する機会を得た (これも FWINDEV に出入りしていたおかげです。
なお，不正コピーの類ではありません。れっきとした正規のα版テスターです，念
のため) ことから，あまり時を経ずして UNLHA32.DLL も登場しています。

　このように『統合アーカイバプロジェクト』は，誰かが音頭をとって始められた
ものではありません。 API についても『ハンドルを使った API も必要になってく
るね…』といったような段階の大まかな仕様が  FWINDEV で話し合われた程度で，
詳細な仕様が策定されたわけではありません。言わば『早い者勝ち』の状況だった
わけで，幸か不幸か UNARJ.DLL が叩き台となってしまい， それで採用されていた
ものが，そのまま固まってしまったのです。 最初に作成された DLL が UNLHA.DLL
であったのなら随分違っていたのでしょうが， 不幸にも UNARJ.DLL だったため，
反応があまりなく，そのままズルズルと…。悪いのは私です。ごめんなさい，ごめ
んなさい，ごめんなさい。(笑)

　ちなみに，『統合アーカイバプロジェクト』の名前は shoda T. 氏によるもので，
今も現存する Web ページ  (善意による個人開設) の立ち上げに際して使われたの
が最初だったはずです。

==========================================================================
